/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.4.0 (NJsonSchema v10.3.7.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import {
  mergeMap as _observableMergeMap,
  catchError as _observableCatch,
} from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import {
  HttpClient,
  HttpHeaders,
  HttpResponse,
  HttpResponseBase,
} from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAccountsClient {
  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfAccountVm>;
  getAdmins(role: Role | null | undefined): Observable<AccountVm[]>;
  refreshToken(): Observable<HttpResultOfString>;
  login(command: LoginCommand): Observable<HttpResultOfString>;
  externalLogin(command: ExternalLoginCommand): Observable<HttpResultOfString>;
  externalRegistration(command: ExternalRegisterCommand): Observable<HttpResultOfString>;
  post(command: AccountsPostCommand): Observable<HttpResultOfString>;
  changePassword(command: ChangePasswordCommand): Observable<void>;
  changePhoneNumber(command: ChangePhoneNumberCommand): Observable<void>;
  putRole(command: AccountsPutRoleCommand): Observable<void>;
  ban(command: AccountsBanCommand): Observable<void>;
  delete(id: string | null): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class AccountsClient implements IAccountsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfAccountVm> {
    let url_ = this.baseUrl + '/api/Accounts/GetPage?';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(<any>response_);
            } catch (e) {
              return <Observable<PaginatedListOfAccountVm>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<PaginatedListOfAccountVm>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfAccountVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfAccountVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getAdmins(role: Role | null | undefined): Observable<AccountVm[]> {
    let url_ = this.baseUrl + '/api/Accounts/GetAdmins?';
    if (role !== undefined && role !== null)
      url_ += 'Role=' + encodeURIComponent('' + role) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAdmins(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAdmins(<any>response_);
            } catch (e) {
              return <Observable<AccountVm[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<AccountVm[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAdmins(response: HttpResponseBase): Observable<AccountVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(AccountVm.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  refreshToken(): Observable<HttpResultOfString> {
    let url_ = this.baseUrl + '/api/Accounts/RefreshToken';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRefreshToken(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRefreshToken(<any>response_);
            } catch (e) {
              return <Observable<HttpResultOfString>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<HttpResultOfString>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processRefreshToken(
    response: HttpResponseBase
  ): Observable<HttpResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  login(command: LoginCommand): Observable<HttpResultOfString> {
    let url_ = this.baseUrl + '/api/Accounts/Login';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processLogin(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processLogin(<any>response_);
            } catch (e) {
              return <Observable<HttpResultOfString>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<HttpResultOfString>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processLogin(response: HttpResponseBase): Observable<HttpResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  externalLogin(command: ExternalLoginCommand): Observable<HttpResultOfString> {
    let url_ = this.baseUrl + '/api/Accounts/ExternalLogin';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExternalLogin(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExternalLogin(<any>response_);
            } catch (e) {
              return <Observable<HttpResultOfString>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<HttpResultOfString>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processExternalLogin(
    response: HttpResponseBase
  ): Observable<HttpResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  externalRegistration(command: ExternalRegisterCommand): Observable<HttpResultOfString> {
    let url_ = this.baseUrl + '/api/Accounts/ExternalRegistration';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExternalRegistration(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExternalRegistration(<any>response_);
            } catch (e) {
              return <Observable<HttpResultOfString>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<HttpResultOfString>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processExternalRegistration(
    response: HttpResponseBase
  ): Observable<HttpResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  post(command: AccountsPostCommand): Observable<HttpResultOfString> {
    let url_ = this.baseUrl + '/api/Accounts';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPost(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPost(<any>response_);
            } catch (e) {
              return <Observable<HttpResultOfString>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<HttpResultOfString>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPost(response: HttpResponseBase): Observable<HttpResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  changePassword(command: ChangePasswordCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/Accounts/ChangePassword';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangePassword(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangePassword(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processChangePassword(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  changePhoneNumber(command: ChangePhoneNumberCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/Accounts/ChangePhoneNumber';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangePhoneNumber(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangePhoneNumber(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processChangePhoneNumber(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  putRole(command: AccountsPutRoleCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/Accounts/PutRole';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPutRole(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPutRole(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPutRole(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  ban(command: AccountsBanCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/Accounts/Ban';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processBan(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processBan(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processBan(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  delete(id: string | null): Observable<void> {
    let url_ = this.baseUrl + '/api/Accounts/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IAdsClient {
  get(): Observable<AdVm>;
  post(
    type: AdType | undefined,
    title_Ar: string | null | undefined,
    title_En: string | null | undefined,
    banner: FileParameter | null | undefined,
    content: string | null | undefined,
    url: string | null | undefined,
    endAt: Date | undefined
  ): Observable<HttpResultOfInteger>;
  put(
    id: number | undefined,
    title_Ar: string | null | undefined,
    title_En: string | null | undefined,
    banner: FileParameter | null | undefined,
    content: string | null | undefined,
    url: string | null | undefined,
    endAt: Date | undefined
  ): Observable<void>;
  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfAdDashboardVm>;
  get2(id: number): Observable<AdDto>;
  putLive(id: number, isLive: boolean | undefined): Observable<void>;
  republish(id: number): Observable<void>;
  delete(id: number): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class AdsClient implements IAdsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  get(): Observable<AdVm> {
    let url_ = this.baseUrl + '/api/Ads';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<AdVm>>(<any>_observableThrow(e));
            }
          } else return <Observable<AdVm>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<AdVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AdVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  post(
    type: AdType | undefined,
    title_Ar: string | null | undefined,
    title_En: string | null | undefined,
    banner: FileParameter | null | undefined,
    content: string | null | undefined,
    url: string | null | undefined,
    endAt: Date | undefined
  ): Observable<HttpResultOfInteger> {
    let url_ = this.baseUrl + '/api/Ads';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = new FormData();
    if (type === null || type === undefined)
      throw new Error("The parameter 'type' cannot be null.");
    else content_.append('Type', type.toString());
    if (title_Ar !== null && title_Ar !== undefined)
      content_.append('Title.Ar', title_Ar.toString());
    if (title_En !== null && title_En !== undefined)
      content_.append('Title.En', title_En.toString());
    if (banner !== null && banner !== undefined)
      content_.append(
        'Banner',
        banner.data,
        banner.fileName ? banner.fileName : 'Banner'
      );
    if (content !== null && content !== undefined)
      content_.append('Content', content.toString());
    if (url !== null && url !== undefined) content_.append('Url', url.toString());
    if (endAt === null || endAt === undefined)
      throw new Error("The parameter 'endAt' cannot be null.");
    else content_.append('EndAt', endAt.toJSON());

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPost(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPost(<any>response_);
            } catch (e) {
              return <Observable<HttpResultOfInteger>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<HttpResultOfInteger>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPost(response: HttpResponseBase): Observable<HttpResultOfInteger> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfInteger.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  put(
    id: number | undefined,
    title_Ar: string | null | undefined,
    title_En: string | null | undefined,
    banner: FileParameter | null | undefined,
    content: string | null | undefined,
    url: string | null | undefined,
    endAt: Date | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/Ads';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = new FormData();
    if (id === null || id === undefined)
      throw new Error("The parameter 'id' cannot be null.");
    else content_.append('Id', id.toString());
    if (title_Ar !== null && title_Ar !== undefined)
      content_.append('Title.Ar', title_Ar.toString());
    if (title_En !== null && title_En !== undefined)
      content_.append('Title.En', title_En.toString());
    if (banner !== null && banner !== undefined)
      content_.append(
        'Banner',
        banner.data,
        banner.fileName ? banner.fileName : 'Banner'
      );
    if (content !== null && content !== undefined)
      content_.append('Content', content.toString());
    if (url !== null && url !== undefined) content_.append('Url', url.toString());
    if (endAt === null || endAt === undefined)
      throw new Error("The parameter 'endAt' cannot be null.");
    else content_.append('EndAt', endAt.toJSON());

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfAdDashboardVm> {
    let url_ = this.baseUrl + '/api/Ads/GetPage?';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(<any>response_);
            } catch (e) {
              return <Observable<PaginatedListOfAdDashboardVm>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<PaginatedListOfAdDashboardVm>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfAdDashboardVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfAdDashboardVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  get2(id: number): Observable<AdDto> {
    let url_ = this.baseUrl + '/api/Ads/Get/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet2(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet2(<any>response_);
            } catch (e) {
              return <Observable<AdDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<AdDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet2(response: HttpResponseBase): Observable<AdDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AdDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  putLive(id: number, isLive: boolean | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/Ads/PutLive/{id}?';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (isLive === null) throw new Error("The parameter 'isLive' cannot be null.");
    else if (isLive !== undefined)
      url_ += 'isLive=' + encodeURIComponent('' + isLive) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPutLive(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPutLive(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPutLive(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  republish(id: number): Observable<void> {
    let url_ = this.baseUrl + '/api/Ads/Republish/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRepublish(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRepublish(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processRepublish(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  delete(id: number): Observable<void> {
    let url_ = this.baseUrl + '/api/Ads/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface ICategoriesClient {
  getAll(): Observable<GroupingOfCategoryVm[]>;
  post(
    name_Ar: string | null | undefined,
    name_En: string | null | undefined,
    type: CategoryType | undefined,
    svg: FileParameter | null | undefined,
    isDisabled: boolean | undefined,
    isGroupCategory: boolean | undefined,
    groupCategoryId: number | null | undefined
  ): Observable<HttpResultOfInteger>;
  put(
    id: number | undefined,
    name_Ar: string | null | undefined,
    name_En: string | null | undefined,
    type: CategoryType | undefined,
    svg: FileParameter | null | undefined,
    isDisabled: boolean | undefined,
    isGroupCategory: boolean | undefined,
    groupCategoryId: number | null | undefined
  ): Observable<void>;
  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfCategoryDashboardVm>;
  get(id: number): Observable<CategoryDto>;
  delete(id: number): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class CategoriesClient implements ICategoriesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getAll(): Observable<GroupingOfCategoryVm[]> {
    let url_ = this.baseUrl + '/api/Categories';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<GroupingOfCategoryVm[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<GroupingOfCategoryVm[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<GroupingOfCategoryVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(GroupingOfCategoryVm.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  post(
    name_Ar: string | null | undefined,
    name_En: string | null | undefined,
    type: CategoryType | undefined,
    svg: FileParameter | null | undefined,
    isDisabled: boolean | undefined,
    isGroupCategory: boolean | undefined,
    groupCategoryId: number | null | undefined
  ): Observable<HttpResultOfInteger> {
    let url_ = this.baseUrl + '/api/Categories';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = new FormData();
    if (name_Ar !== null && name_Ar !== undefined)
      content_.append('Name.Ar', name_Ar.toString());
    if (name_En !== null && name_En !== undefined)
      content_.append('Name.En', name_En.toString());
    if (type === null || type === undefined)
      throw new Error("The parameter 'type' cannot be null.");
    else content_.append('Type', type.toString());
    if (svg !== null && svg !== undefined)
      content_.append('Svg', svg.data, svg.fileName ? svg.fileName : 'Svg');
    if (isDisabled === null || isDisabled === undefined)
      throw new Error("The parameter 'isDisabled' cannot be null.");
    else content_.append('IsDisabled', isDisabled.toString());
    if (isGroupCategory === null || isGroupCategory === undefined)
      throw new Error("The parameter 'isGroupCategory' cannot be null.");
    else content_.append('IsGroupCategory', isGroupCategory.toString());
    if (groupCategoryId !== null && groupCategoryId !== undefined)
      content_.append('GroupCategoryId', groupCategoryId.toString());

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPost(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPost(<any>response_);
            } catch (e) {
              return <Observable<HttpResultOfInteger>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<HttpResultOfInteger>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPost(response: HttpResponseBase): Observable<HttpResultOfInteger> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfInteger.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  put(
    id: number | undefined,
    name_Ar: string | null | undefined,
    name_En: string | null | undefined,
    type: CategoryType | undefined,
    svg: FileParameter | null | undefined,
    isDisabled: boolean | undefined,
    isGroupCategory: boolean | undefined,
    groupCategoryId: number | null | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/Categories';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = new FormData();
    if (id === null || id === undefined)
      throw new Error("The parameter 'id' cannot be null.");
    else content_.append('Id', id.toString());
    if (name_Ar !== null && name_Ar !== undefined)
      content_.append('Name.Ar', name_Ar.toString());
    if (name_En !== null && name_En !== undefined)
      content_.append('Name.En', name_En.toString());
    if (type === null || type === undefined)
      throw new Error("The parameter 'type' cannot be null.");
    else content_.append('Type', type.toString());
    if (svg !== null && svg !== undefined)
      content_.append('Svg', svg.data, svg.fileName ? svg.fileName : 'Svg');
    if (isDisabled === null || isDisabled === undefined)
      throw new Error("The parameter 'isDisabled' cannot be null.");
    else content_.append('IsDisabled', isDisabled.toString());
    if (isGroupCategory === null || isGroupCategory === undefined)
      throw new Error("The parameter 'isGroupCategory' cannot be null.");
    else content_.append('IsGroupCategory', isGroupCategory.toString());
    if (groupCategoryId !== null && groupCategoryId !== undefined)
      content_.append('GroupCategoryId', groupCategoryId.toString());

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfCategoryDashboardVm> {
    let url_ = this.baseUrl + '/api/Categories/GetPage?';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(<any>response_);
            } catch (e) {
              return <Observable<PaginatedListOfCategoryDashboardVm>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<PaginatedListOfCategoryDashboardVm>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfCategoryDashboardVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfCategoryDashboardVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  get(id: number): Observable<CategoryDto> {
    let url_ = this.baseUrl + '/api/Categories/Get/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<CategoryDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<CategoryDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<CategoryDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CategoryDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  delete(id: number): Observable<void> {
    let url_ = this.baseUrl + '/api/Categories/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface ICertificationsClient {
  getList(): Observable<CertificationDataDto[]>;
  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfCertificationVm>;
  put(command: CertificationsPutDataCommand): Observable<void>;
  putStatus(command: CertificationsPutStatusCommand): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class CertificationsClient implements ICertificationsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getList(): Observable<CertificationDataDto[]> {
    let url_ = this.baseUrl + '/api/Certifications/GetList';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetList(<any>response_);
            } catch (e) {
              return <Observable<CertificationDataDto[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<CertificationDataDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetList(
    response: HttpResponseBase
  ): Observable<CertificationDataDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(CertificationDataDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfCertificationVm> {
    let url_ = this.baseUrl + '/api/Certifications/GetPage?';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(<any>response_);
            } catch (e) {
              return <Observable<PaginatedListOfCertificationVm>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<PaginatedListOfCertificationVm>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfCertificationVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfCertificationVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  put(command: CertificationsPutDataCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/Certifications';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  putStatus(command: CertificationsPutStatusCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/Certifications/PutStatus';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPutStatus(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPutStatus(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPutStatus(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IChatsClient {
  get(): Observable<ChatVm[]>;
  getMessages(
    chatId: number | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfMessageVm>;
  sendMessage(
    chatId: number | undefined,
    receiverUsername: string | null | undefined,
    content: string | null | undefined,
    file: FileParameter | null | undefined,
    type: MessageType | undefined
  ): Observable<HttpResultOfInteger>;
}

@Injectable({
  providedIn: 'root',
})
export class ChatsClient implements IChatsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  get(): Observable<ChatVm[]> {
    let url_ = this.baseUrl + '/api/Chats';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<ChatVm[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<ChatVm[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<ChatVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ChatVm.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getMessages(
    chatId: number | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfMessageVm> {
    let url_ = this.baseUrl + '/api/Chats/GetMessages?';
    if (chatId === null) throw new Error("The parameter 'chatId' cannot be null.");
    else if (chatId !== undefined)
      url_ += 'ChatId=' + encodeURIComponent('' + chatId) + '&';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetMessages(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetMessages(<any>response_);
            } catch (e) {
              return <Observable<PaginatedListOfMessageVm>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<PaginatedListOfMessageVm>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetMessages(
    response: HttpResponseBase
  ): Observable<PaginatedListOfMessageVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfMessageVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  sendMessage(
    chatId: number | undefined,
    receiverUsername: string | null | undefined,
    content: string | null | undefined,
    file: FileParameter | null | undefined,
    type: MessageType | undefined
  ): Observable<HttpResultOfInteger> {
    let url_ = this.baseUrl + '/api/Chats/SendMessage';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = new FormData();
    if (chatId === null || chatId === undefined)
      throw new Error("The parameter 'chatId' cannot be null.");
    else content_.append('ChatId', chatId.toString());
    if (receiverUsername !== null && receiverUsername !== undefined)
      content_.append('ReceiverUsername', receiverUsername.toString());
    if (content !== null && content !== undefined)
      content_.append('Content', content.toString());
    if (file !== null && file !== undefined)
      content_.append('File', file.data, file.fileName ? file.fileName : 'File');
    if (type === null || type === undefined)
      throw new Error("The parameter 'type' cannot be null.");
    else content_.append('Type', type.toString());

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSendMessage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSendMessage(<any>response_);
            } catch (e) {
              return <Observable<HttpResultOfInteger>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<HttpResultOfInteger>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processSendMessage(
    response: HttpResponseBase
  ): Observable<HttpResultOfInteger> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfInteger.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface ICitiesClient {
  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfCityDto>;
  getDashboardList(): Observable<CityDashboardVm[]>;
  post(command: CitiesPostCommand): Observable<HttpResultOfInteger>;
  put(command: CitiesPutCommand): Observable<void>;
  delete(id: number | undefined): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class CitiesClient implements ICitiesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfCityDto> {
    let url_ = this.baseUrl + '/api/Cities/GetPage?';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(<any>response_);
            } catch (e) {
              return <Observable<PaginatedListOfCityDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<PaginatedListOfCityDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfCityDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfCityDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getDashboardList(): Observable<CityDashboardVm[]> {
    let url_ = this.baseUrl + '/api/Cities/GetDashboardList';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDashboardList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDashboardList(<any>response_);
            } catch (e) {
              return <Observable<CityDashboardVm[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<CityDashboardVm[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDashboardList(
    response: HttpResponseBase
  ): Observable<CityDashboardVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(CityDashboardVm.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  post(command: CitiesPostCommand): Observable<HttpResultOfInteger> {
    let url_ = this.baseUrl + '/api/Cities';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPost(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPost(<any>response_);
            } catch (e) {
              return <Observable<HttpResultOfInteger>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<HttpResultOfInteger>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPost(response: HttpResponseBase): Observable<HttpResultOfInteger> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfInteger.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  put(command: CitiesPutCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/Cities';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/Cities?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface ICloseReasonsClient {
  get(): Observable<CloseReasonVm[]>;
  post(command: CloseReasonsPostCommand): Observable<HttpResultOfInteger>;
  put(command: CloseReasonsPutCommand): Observable<void>;
  delete(id: number | undefined): Observable<void>;
  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfCloseReasonDto>;
}

@Injectable({
  providedIn: 'root',
})
export class CloseReasonsClient implements ICloseReasonsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  get(): Observable<CloseReasonVm[]> {
    let url_ = this.baseUrl + '/api/CloseReasons';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<CloseReasonVm[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<CloseReasonVm[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<CloseReasonVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(CloseReasonVm.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  post(command: CloseReasonsPostCommand): Observable<HttpResultOfInteger> {
    let url_ = this.baseUrl + '/api/CloseReasons';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPost(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPost(<any>response_);
            } catch (e) {
              return <Observable<HttpResultOfInteger>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<HttpResultOfInteger>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPost(response: HttpResponseBase): Observable<HttpResultOfInteger> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfInteger.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  put(command: CloseReasonsPutCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/CloseReasons';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/CloseReasons?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfCloseReasonDto> {
    let url_ = this.baseUrl + '/api/CloseReasons/GetPage?';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(<any>response_);
            } catch (e) {
              return <Observable<PaginatedListOfCloseReasonDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<PaginatedListOfCloseReasonDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfCloseReasonDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfCloseReasonDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface ICommonQuestionsClient {
  get(): Observable<CommonQuestionVm[]>;
  post(command: CommonQuestionsPostCommand): Observable<HttpResultOfInteger>;
  put(command: CommonQuestionsPutCommand): Observable<void>;
  delete(id: number | undefined): Observable<void>;
  getPage(): Observable<CommonQuestionDto[]>;
  putOrder(command: CommonQuestionsPutOrderCommand): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class CommonQuestionsClient implements ICommonQuestionsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  get(): Observable<CommonQuestionVm[]> {
    let url_ = this.baseUrl + '/api/CommonQuestions';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<CommonQuestionVm[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<CommonQuestionVm[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<CommonQuestionVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(CommonQuestionVm.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  post(command: CommonQuestionsPostCommand): Observable<HttpResultOfInteger> {
    let url_ = this.baseUrl + '/api/CommonQuestions';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPost(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPost(<any>response_);
            } catch (e) {
              return <Observable<HttpResultOfInteger>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<HttpResultOfInteger>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPost(response: HttpResponseBase): Observable<HttpResultOfInteger> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfInteger.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  put(command: CommonQuestionsPutCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/CommonQuestions';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/CommonQuestions?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getPage(): Observable<CommonQuestionDto[]> {
    let url_ = this.baseUrl + '/api/CommonQuestions/GetPage';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(<any>response_);
            } catch (e) {
              return <Observable<CommonQuestionDto[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<CommonQuestionDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetPage(response: HttpResponseBase): Observable<CommonQuestionDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(CommonQuestionDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  putOrder(command: CommonQuestionsPutOrderCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/CommonQuestions/PutOrder';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPutOrder(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPutOrder(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPutOrder(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IDataFieldsClient {
  getDependantList(): Observable<DataFieldDependantVm[]>;
  get(id: number): Observable<DataFieldDto>;
  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfDataFieldDashboardVm>;
  post(command: DataFieldsPostCommand): Observable<HttpResultOfInteger>;
  put(command: DataFieldsPutCommand): Observable<void>;
  delete(id: number | undefined): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class DataFieldsClient implements IDataFieldsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getDependantList(): Observable<DataFieldDependantVm[]> {
    let url_ = this.baseUrl + '/api/DataFields/GetDependantList';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDependantList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDependantList(<any>response_);
            } catch (e) {
              return <Observable<DataFieldDependantVm[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<DataFieldDependantVm[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDependantList(
    response: HttpResponseBase
  ): Observable<DataFieldDependantVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(DataFieldDependantVm.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  get(id: number): Observable<DataFieldDto> {
    let url_ = this.baseUrl + '/api/DataFields/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<DataFieldDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<DataFieldDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<DataFieldDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = DataFieldDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfDataFieldDashboardVm> {
    let url_ = this.baseUrl + '/api/DataFields/GetPage?';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(<any>response_);
            } catch (e) {
              return <Observable<PaginatedListOfDataFieldDashboardVm>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<PaginatedListOfDataFieldDashboardVm>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfDataFieldDashboardVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfDataFieldDashboardVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  post(command: DataFieldsPostCommand): Observable<HttpResultOfInteger> {
    let url_ = this.baseUrl + '/api/DataFields';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPost(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPost(<any>response_);
            } catch (e) {
              return <Observable<HttpResultOfInteger>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<HttpResultOfInteger>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPost(response: HttpResponseBase): Observable<HttpResultOfInteger> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfInteger.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  put(command: DataFieldsPutCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/DataFields';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/DataFields?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IFavoritesClient {
  get(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfPostVm>;
  put(postId: string | null, favorite: boolean | undefined): Observable<FileResponse>;
}

@Injectable({
  providedIn: 'root',
})
export class FavoritesClient implements IFavoritesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  get(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfPostVm> {
    let url_ = this.baseUrl + '/api/Favorites?';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<PaginatedListOfPostVm>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<PaginatedListOfPostVm>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<PaginatedListOfPostVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfPostVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  put(postId: string | null, favorite: boolean | undefined): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/Favorites/{postId}?';
    if (postId === undefined || postId === null)
      throw new Error("The parameter 'postId' must be defined.");
    url_ = url_.replace('{postId}', encodeURIComponent('' + postId));
    if (favorite === null) throw new Error("The parameter 'favorite' cannot be null.");
    else if (favorite !== undefined)
      url_ += 'favorite=' + encodeURIComponent('' + favorite) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(<any>response_);
            } catch (e) {
              return <Observable<FileResponse>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPut(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return _observableOf({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<FileResponse>(<any>null);
  }
}

export interface ILinksClient {
  get(): Observable<GroupingOfLinkVm[]>;
  post(command: LinksPostCommand): Observable<HttpResultOfInteger>;
  put(command: LinksPutCommand): Observable<void>;
  delete(id: number | undefined): Observable<void>;
  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfLinkDto>;
}

@Injectable({
  providedIn: 'root',
})
export class LinksClient implements ILinksClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  get(): Observable<GroupingOfLinkVm[]> {
    let url_ = this.baseUrl + '/api/Links';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<GroupingOfLinkVm[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<GroupingOfLinkVm[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<GroupingOfLinkVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(GroupingOfLinkVm.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  post(command: LinksPostCommand): Observable<HttpResultOfInteger> {
    let url_ = this.baseUrl + '/api/Links';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPost(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPost(<any>response_);
            } catch (e) {
              return <Observable<HttpResultOfInteger>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<HttpResultOfInteger>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPost(response: HttpResponseBase): Observable<HttpResultOfInteger> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfInteger.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  put(command: LinksPutCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/Links';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/Links?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfLinkDto> {
    let url_ = this.baseUrl + '/api/Links/GetPage?';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(<any>response_);
            } catch (e) {
              return <Observable<PaginatedListOfLinkDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<PaginatedListOfLinkDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfLinkDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfLinkDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface INotificationsClient {
  get(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfNotificationVm>;
  markAsRead(id: number): Observable<void>;
  markAllAsRead(): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class NotificationsClient implements INotificationsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  get(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfNotificationVm> {
    let url_ = this.baseUrl + '/api/Notifications?';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<PaginatedListOfNotificationVm>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<PaginatedListOfNotificationVm>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(
    response: HttpResponseBase
  ): Observable<PaginatedListOfNotificationVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfNotificationVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  markAsRead(id: number): Observable<void> {
    let url_ = this.baseUrl + '/api/Notifications/MarkAsRead/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processMarkAsRead(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processMarkAsRead(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processMarkAsRead(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  markAllAsRead(): Observable<void> {
    let url_ = this.baseUrl + '/api/Notifications/MarkAllAsRead';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processMarkAllAsRead(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processMarkAllAsRead(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processMarkAllAsRead(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IPlacesClient {
  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfPlaceDashboardVm>;
  post(command: PlacesPostCommand): Observable<HttpResultOfInteger>;
  put(command: PlacesPutCommand): Observable<void>;
  delete(id: number | undefined): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class PlacesClient implements IPlacesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfPlaceDashboardVm> {
    let url_ = this.baseUrl + '/api/Places/GetPage?';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(<any>response_);
            } catch (e) {
              return <Observable<PaginatedListOfPlaceDashboardVm>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<PaginatedListOfPlaceDashboardVm>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfPlaceDashboardVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfPlaceDashboardVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  post(command: PlacesPostCommand): Observable<HttpResultOfInteger> {
    let url_ = this.baseUrl + '/api/Places';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPost(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPost(<any>response_);
            } catch (e) {
              return <Observable<HttpResultOfInteger>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<HttpResultOfInteger>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPost(response: HttpResponseBase): Observable<HttpResultOfInteger> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfInteger.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  put(command: PlacesPutCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/Places';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/Places?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IPostsClient {
  getFilters(): Observable<PostFilterDto[]>;
  getPosts(
    all: boolean | undefined,
    claro: boolean | undefined,
    categoryId: number | null | undefined,
    forSale: boolean | undefined,
    forRental: boolean | undefined,
    cityId: number | null | undefined,
    regionId: number | null | undefined,
    subRegionId: number | null | undefined,
    minSize: number | null | undefined,
    maxSize: number | null | undefined,
    minPrice: number | null | undefined,
    maxPrice: number | null | undefined,
    filters: PostFilterDto[] | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfPostVm>;
  getGroups(): Observable<PostGroups>;
  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfPostDashboardVm>;
  getAccountPosts(): Observable<PostVm[]>;
  getPost(perma: string | null): Observable<PostDetailsVm>;
  get(postId: string | null | undefined): Observable<PostDto>;
  post(
    certification_Type: CertificationType | undefined,
    certification_RequestedAt: Date | undefined,
    location_CityId: number | undefined,
    location_RegionId: number | undefined,
    location_ParentSubRegionId: number | null | undefined,
    location_SubRegionId: number | null | undefined,
    location_Longitude: number | undefined,
    location_Latitude: number | undefined,
    sellingDetails_PaymentType: PaymentType | undefined,
    sellingDetails_Price: number | undefined,
    sellingDetails_FirstBatch: number | null | undefined,
    sellingDetails_Remaining: number | null | undefined,
    sellingDetails_InstallmentYears: number | null | undefined,
    sellingDetails_IsNegotiable: boolean | undefined,
    sellingDetails_IncludesMaintenanceDeposit: boolean | undefined,
    rentingDetails_PeriodType: PeriodType | undefined,
    rentingDetails_PeriodRange: number | undefined,
    rentingDetails_Price: number | undefined,
    rentingDetails_AnnualIncreaseRate: number | undefined,
    rentingDetails_AnnualIncreaseValue: number | undefined,
    rentingDetails_MaintenanceType: MaintenanceType | undefined,
    rentingDetails_InsuranceType: InsuranceType | undefined,
    rentingDetails_MaintenanceValue: number | undefined,
    rentingDetails_InsuranceValue: number | undefined,
    size: number | undefined,
    netSize: number | null | undefined,
    ownerRelation: OwnerRelation | undefined,
    categoryId: number | undefined,
    attachments: AttachmentDto[] | null | undefined,
    categories: CategoryFullVm[] | null | undefined,
    cities: CityVm[] | null | undefined,
    places: PlaceVm[] | null | undefined,
    certifications: CertificationDataVm[] | null | undefined
  ): Observable<PostResult>;
  put(
    postId: string | null | undefined,
    location_CityId: number | undefined,
    location_RegionId: number | undefined,
    location_ParentSubRegionId: number | null | undefined,
    location_SubRegionId: number | null | undefined,
    location_Longitude: number | undefined,
    location_Latitude: number | undefined,
    sellingDetails_PaymentType: PaymentType | undefined,
    sellingDetails_Price: number | undefined,
    sellingDetails_FirstBatch: number | null | undefined,
    sellingDetails_Remaining: number | null | undefined,
    sellingDetails_InstallmentYears: number | null | undefined,
    sellingDetails_IsNegotiable: boolean | undefined,
    sellingDetails_IncludesMaintenanceDeposit: boolean | undefined,
    rentingDetails_PeriodType: PeriodType | undefined,
    rentingDetails_PeriodRange: number | undefined,
    rentingDetails_Price: number | undefined,
    rentingDetails_AnnualIncreaseRate: number | undefined,
    rentingDetails_AnnualIncreaseValue: number | undefined,
    rentingDetails_MaintenanceType: MaintenanceType | undefined,
    rentingDetails_InsuranceType: InsuranceType | undefined,
    rentingDetails_MaintenanceValue: number | undefined,
    rentingDetails_InsuranceValue: number | undefined,
    size: number | undefined,
    netSize: number | null | undefined,
    ownerRelation: OwnerRelation | undefined,
    categoryId: number | undefined,
    attachments: AttachmentDto[] | null | undefined,
    categories: CategoryFullVm[] | null | undefined,
    cities: CityVm[] | null | undefined,
    places: PlaceVm[] | null | undefined,
    certifications: CertificationDataVm[] | null | undefined
  ): Observable<void>;
  delete(postId: string | null | undefined): Observable<void>;
  putStatus(command: PostsPutStatusCommand): Observable<void>;
  deleteAttachment(
    postId: string | null | undefined,
    attachmentId: number | undefined
  ): Observable<FileResponse>;
  close(command: PostsCloseCommand): Observable<FileResponse>;
}

@Injectable({
  providedIn: 'root',
})
export class PostsClient implements IPostsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getFilters(): Observable<PostFilterDto[]> {
    let url_ = this.baseUrl + '/api/Posts/GetFilters';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetFilters(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetFilters(<any>response_);
            } catch (e) {
              return <Observable<PostFilterDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<PostFilterDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetFilters(response: HttpResponseBase): Observable<PostFilterDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(PostFilterDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getPosts(
    all: boolean | undefined,
    claro: boolean | undefined,
    categoryId: number | null | undefined,
    forSale: boolean | undefined,
    forRental: boolean | undefined,
    cityId: number | null | undefined,
    regionId: number | null | undefined,
    subRegionId: number | null | undefined,
    minSize: number | null | undefined,
    maxSize: number | null | undefined,
    minPrice: number | null | undefined,
    maxPrice: number | null | undefined,
    filters: PostFilterDto[] | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfPostVm> {
    let url_ = this.baseUrl + '/api/Posts/GetPosts?';
    if (all === null) throw new Error("The parameter 'all' cannot be null.");
    else if (all !== undefined) url_ += 'All=' + encodeURIComponent('' + all) + '&';
    if (claro === null) throw new Error("The parameter 'claro' cannot be null.");
    else if (claro !== undefined) url_ += 'Claro=' + encodeURIComponent('' + claro) + '&';
    if (categoryId !== undefined && categoryId !== null)
      url_ += 'CategoryId=' + encodeURIComponent('' + categoryId) + '&';
    if (forSale === null) throw new Error("The parameter 'forSale' cannot be null.");
    else if (forSale !== undefined)
      url_ += 'ForSale=' + encodeURIComponent('' + forSale) + '&';
    if (forRental === null) throw new Error("The parameter 'forRental' cannot be null.");
    else if (forRental !== undefined)
      url_ += 'ForRental=' + encodeURIComponent('' + forRental) + '&';
    if (cityId !== undefined && cityId !== null)
      url_ += 'CityId=' + encodeURIComponent('' + cityId) + '&';
    if (regionId !== undefined && regionId !== null)
      url_ += 'RegionId=' + encodeURIComponent('' + regionId) + '&';
    if (subRegionId !== undefined && subRegionId !== null)
      url_ += 'SubRegionId=' + encodeURIComponent('' + subRegionId) + '&';
    if (minSize !== undefined && minSize !== null)
      url_ += 'MinSize=' + encodeURIComponent('' + minSize) + '&';
    if (maxSize !== undefined && maxSize !== null)
      url_ += 'MaxSize=' + encodeURIComponent('' + maxSize) + '&';
    if (minPrice !== undefined && minPrice !== null)
      url_ += 'MinPrice=' + encodeURIComponent('' + minPrice) + '&';
    if (maxPrice !== undefined && maxPrice !== null)
      url_ += 'MaxPrice=' + encodeURIComponent('' + maxPrice) + '&';
    if (filters !== undefined && filters !== null)
      filters &&
        filters.forEach((item, index) => {
          for (let attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ +=
                'Filters[' +
                index +
                '].' +
                attr +
                '=' +
                encodeURIComponent('' + (<any>item)[attr]) +
                '&';
            }
        });
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPosts(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPosts(<any>response_);
            } catch (e) {
              return <Observable<PaginatedListOfPostVm>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<PaginatedListOfPostVm>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetPosts(
    response: HttpResponseBase
  ): Observable<PaginatedListOfPostVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfPostVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getGroups(): Observable<PostGroups> {
    let url_ = this.baseUrl + '/api/Posts/GetGroups';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetGroups(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetGroups(<any>response_);
            } catch (e) {
              return <Observable<PostGroups>>(<any>_observableThrow(e));
            }
          } else return <Observable<PostGroups>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetGroups(response: HttpResponseBase): Observable<PostGroups> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PostGroups.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfPostDashboardVm> {
    let url_ = this.baseUrl + '/api/Posts/GetPage?';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(<any>response_);
            } catch (e) {
              return <Observable<PaginatedListOfPostDashboardVm>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<PaginatedListOfPostDashboardVm>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfPostDashboardVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfPostDashboardVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getAccountPosts(): Observable<PostVm[]> {
    let url_ = this.baseUrl + '/api/Posts/GetAccountPosts';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAccountPosts(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAccountPosts(<any>response_);
            } catch (e) {
              return <Observable<PostVm[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<PostVm[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAccountPosts(response: HttpResponseBase): Observable<PostVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(PostVm.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getPost(perma: string | null): Observable<PostDetailsVm> {
    let url_ = this.baseUrl + '/api/Posts/GetPost/{perma}';
    if (perma === undefined || perma === null)
      throw new Error("The parameter 'perma' must be defined.");
    url_ = url_.replace('{perma}', encodeURIComponent('' + perma));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPost(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPost(<any>response_);
            } catch (e) {
              return <Observable<PostDetailsVm>>(<any>_observableThrow(e));
            }
          } else return <Observable<PostDetailsVm>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetPost(response: HttpResponseBase): Observable<PostDetailsVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PostDetailsVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  get(postId: string | null | undefined): Observable<PostDto> {
    let url_ = this.baseUrl + '/api/Posts?';
    if (postId !== undefined && postId !== null)
      url_ += 'postId=' + encodeURIComponent('' + postId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<PostDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PostDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<PostDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PostDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  post(
    certification_Type: CertificationType | undefined,
    certification_RequestedAt: Date | undefined,
    location_CityId: number | undefined,
    location_RegionId: number | undefined,
    location_ParentSubRegionId: number | null | undefined,
    location_SubRegionId: number | null | undefined,
    location_Longitude: number | undefined,
    location_Latitude: number | undefined,
    sellingDetails_PaymentType: PaymentType | undefined,
    sellingDetails_Price: number | undefined,
    sellingDetails_FirstBatch: number | null | undefined,
    sellingDetails_Remaining: number | null | undefined,
    sellingDetails_InstallmentYears: number | null | undefined,
    sellingDetails_IsNegotiable: boolean | undefined,
    sellingDetails_IncludesMaintenanceDeposit: boolean | undefined,
    rentingDetails_PeriodType: PeriodType | undefined,
    rentingDetails_PeriodRange: number | undefined,
    rentingDetails_Price: number | undefined,
    rentingDetails_AnnualIncreaseRate: number | undefined,
    rentingDetails_AnnualIncreaseValue: number | undefined,
    rentingDetails_MaintenanceType: MaintenanceType | undefined,
    rentingDetails_InsuranceType: InsuranceType | undefined,
    rentingDetails_MaintenanceValue: number | undefined,
    rentingDetails_InsuranceValue: number | undefined,
    size: number | undefined,
    netSize: number | null | undefined,
    ownerRelation: OwnerRelation | undefined,
    categoryId: number | undefined,
    attachments: AttachmentDto[] | null | undefined,
    categories: CategoryFullVm[] | null | undefined,
    cities: CityVm[] | null | undefined,
    places: PlaceVm[] | null | undefined,
    certifications: CertificationDataVm[] | null | undefined
  ): Observable<PostResult> {
    let url_ = this.baseUrl + '/api/Posts';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = new FormData();
    if (certification_Type === null || certification_Type === undefined)
      throw new Error("The parameter 'certification_Type' cannot be null.");
    else content_.append('Certification.Type', certification_Type.toString());
    if (certification_RequestedAt === null || certification_RequestedAt === undefined)
      throw new Error("The parameter 'certification_RequestedAt' cannot be null.");
    else content_.append('Certification.RequestedAt', certification_RequestedAt.toJSON());
    if (location_CityId === null || location_CityId === undefined)
      throw new Error("The parameter 'location_CityId' cannot be null.");
    else content_.append('Location.CityId', location_CityId.toString());
    if (location_RegionId === null || location_RegionId === undefined)
      throw new Error("The parameter 'location_RegionId' cannot be null.");
    else content_.append('Location.RegionId', location_RegionId.toString());
    if (location_ParentSubRegionId !== null && location_ParentSubRegionId !== undefined)
      content_.append(
        'Location.ParentSubRegionId',
        location_ParentSubRegionId.toString()
      );
    if (location_SubRegionId !== null && location_SubRegionId !== undefined)
      content_.append('Location.SubRegionId', location_SubRegionId.toString());
    if (location_Longitude === null || location_Longitude === undefined)
      throw new Error("The parameter 'location_Longitude' cannot be null.");
    else content_.append('Location.Longitude', location_Longitude.toString());
    if (location_Latitude === null || location_Latitude === undefined)
      throw new Error("The parameter 'location_Latitude' cannot be null.");
    else content_.append('Location.Latitude', location_Latitude.toString());
    if (sellingDetails_PaymentType === null || sellingDetails_PaymentType === undefined)
      throw new Error("The parameter 'sellingDetails_PaymentType' cannot be null.");
    else
      content_.append(
        'SellingDetails.PaymentType',
        sellingDetails_PaymentType.toString()
      );
    if (sellingDetails_Price === null || sellingDetails_Price === undefined)
      throw new Error("The parameter 'sellingDetails_Price' cannot be null.");
    else content_.append('SellingDetails.Price', sellingDetails_Price.toString());
    if (sellingDetails_FirstBatch !== null && sellingDetails_FirstBatch !== undefined)
      content_.append('SellingDetails.FirstBatch', sellingDetails_FirstBatch.toString());
    if (sellingDetails_Remaining !== null && sellingDetails_Remaining !== undefined)
      content_.append('SellingDetails.Remaining', sellingDetails_Remaining.toString());
    if (
      sellingDetails_InstallmentYears !== null &&
      sellingDetails_InstallmentYears !== undefined
    )
      content_.append(
        'SellingDetails.InstallmentYears',
        sellingDetails_InstallmentYears.toString()
      );
    if (sellingDetails_IsNegotiable === null || sellingDetails_IsNegotiable === undefined)
      throw new Error("The parameter 'sellingDetails_IsNegotiable' cannot be null.");
    else
      content_.append(
        'SellingDetails.IsNegotiable',
        sellingDetails_IsNegotiable.toString()
      );
    if (
      sellingDetails_IncludesMaintenanceDeposit === null ||
      sellingDetails_IncludesMaintenanceDeposit === undefined
    )
      throw new Error(
        "The parameter 'sellingDetails_IncludesMaintenanceDeposit' cannot be null."
      );
    else
      content_.append(
        'SellingDetails.IncludesMaintenanceDeposit',
        sellingDetails_IncludesMaintenanceDeposit.toString()
      );
    if (rentingDetails_PeriodType === null || rentingDetails_PeriodType === undefined)
      throw new Error("The parameter 'rentingDetails_PeriodType' cannot be null.");
    else
      content_.append('RentingDetails.PeriodType', rentingDetails_PeriodType.toString());
    if (rentingDetails_PeriodRange === null || rentingDetails_PeriodRange === undefined)
      throw new Error("The parameter 'rentingDetails_PeriodRange' cannot be null.");
    else
      content_.append(
        'RentingDetails.PeriodRange',
        rentingDetails_PeriodRange.toString()
      );
    if (rentingDetails_Price === null || rentingDetails_Price === undefined)
      throw new Error("The parameter 'rentingDetails_Price' cannot be null.");
    else content_.append('RentingDetails.Price', rentingDetails_Price.toString());
    if (
      rentingDetails_AnnualIncreaseRate === null ||
      rentingDetails_AnnualIncreaseRate === undefined
    )
      throw new Error(
        "The parameter 'rentingDetails_AnnualIncreaseRate' cannot be null."
      );
    else
      content_.append(
        'RentingDetails.AnnualIncreaseRate',
        rentingDetails_AnnualIncreaseRate.toString()
      );
    if (
      rentingDetails_AnnualIncreaseValue === null ||
      rentingDetails_AnnualIncreaseValue === undefined
    )
      throw new Error(
        "The parameter 'rentingDetails_AnnualIncreaseValue' cannot be null."
      );
    else
      content_.append(
        'RentingDetails.AnnualIncreaseValue',
        rentingDetails_AnnualIncreaseValue.toString()
      );
    if (
      rentingDetails_MaintenanceType === null ||
      rentingDetails_MaintenanceType === undefined
    )
      throw new Error("The parameter 'rentingDetails_MaintenanceType' cannot be null.");
    else
      content_.append(
        'RentingDetails.MaintenanceType',
        rentingDetails_MaintenanceType.toString()
      );
    if (
      rentingDetails_InsuranceType === null ||
      rentingDetails_InsuranceType === undefined
    )
      throw new Error("The parameter 'rentingDetails_InsuranceType' cannot be null.");
    else
      content_.append(
        'RentingDetails.InsuranceType',
        rentingDetails_InsuranceType.toString()
      );
    if (
      rentingDetails_MaintenanceValue === null ||
      rentingDetails_MaintenanceValue === undefined
    )
      throw new Error("The parameter 'rentingDetails_MaintenanceValue' cannot be null.");
    else
      content_.append(
        'RentingDetails.MaintenanceValue',
        rentingDetails_MaintenanceValue.toString()
      );
    if (
      rentingDetails_InsuranceValue === null ||
      rentingDetails_InsuranceValue === undefined
    )
      throw new Error("The parameter 'rentingDetails_InsuranceValue' cannot be null.");
    else
      content_.append(
        'RentingDetails.InsuranceValue',
        rentingDetails_InsuranceValue.toString()
      );
    if (size === null || size === undefined)
      throw new Error("The parameter 'size' cannot be null.");
    else content_.append('Size', size.toString());
    if (netSize !== null && netSize !== undefined)
      content_.append('NetSize', netSize.toString());
    if (ownerRelation === null || ownerRelation === undefined)
      throw new Error("The parameter 'ownerRelation' cannot be null.");
    else content_.append('OwnerRelation', ownerRelation.toString());
    if (categoryId === null || categoryId === undefined)
      throw new Error("The parameter 'categoryId' cannot be null.");
    else content_.append('CategoryId', categoryId.toString());
    if (attachments !== null && attachments !== undefined)
      attachments.forEach((item_) => content_.append('Attachments', item_.toString()));
    if (categories !== null && categories !== undefined)
      categories.forEach((item_) => content_.append('Categories', item_.toString()));
    if (cities !== null && cities !== undefined)
      cities.forEach((item_) => content_.append('Cities', item_.toString()));
    if (places !== null && places !== undefined)
      places.forEach((item_) => content_.append('Places', item_.toString()));
    if (certifications !== null && certifications !== undefined)
      certifications.forEach((item_) =>
        content_.append('Certifications', item_.toString())
      );

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPost(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPost(<any>response_);
            } catch (e) {
              return <Observable<PostResult>>(<any>_observableThrow(e));
            }
          } else return <Observable<PostResult>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPost(response: HttpResponseBase): Observable<PostResult> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PostResult.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  put(
    postId: string | null | undefined,
    location_CityId: number | undefined,
    location_RegionId: number | undefined,
    location_ParentSubRegionId: number | null | undefined,
    location_SubRegionId: number | null | undefined,
    location_Longitude: number | undefined,
    location_Latitude: number | undefined,
    sellingDetails_PaymentType: PaymentType | undefined,
    sellingDetails_Price: number | undefined,
    sellingDetails_FirstBatch: number | null | undefined,
    sellingDetails_Remaining: number | null | undefined,
    sellingDetails_InstallmentYears: number | null | undefined,
    sellingDetails_IsNegotiable: boolean | undefined,
    sellingDetails_IncludesMaintenanceDeposit: boolean | undefined,
    rentingDetails_PeriodType: PeriodType | undefined,
    rentingDetails_PeriodRange: number | undefined,
    rentingDetails_Price: number | undefined,
    rentingDetails_AnnualIncreaseRate: number | undefined,
    rentingDetails_AnnualIncreaseValue: number | undefined,
    rentingDetails_MaintenanceType: MaintenanceType | undefined,
    rentingDetails_InsuranceType: InsuranceType | undefined,
    rentingDetails_MaintenanceValue: number | undefined,
    rentingDetails_InsuranceValue: number | undefined,
    size: number | undefined,
    netSize: number | null | undefined,
    ownerRelation: OwnerRelation | undefined,
    categoryId: number | undefined,
    attachments: AttachmentDto[] | null | undefined,
    categories: CategoryFullVm[] | null | undefined,
    cities: CityVm[] | null | undefined,
    places: PlaceVm[] | null | undefined,
    certifications: CertificationDataVm[] | null | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/Posts';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = new FormData();
    if (postId !== null && postId !== undefined)
      content_.append('PostId', postId.toString());
    if (location_CityId === null || location_CityId === undefined)
      throw new Error("The parameter 'location_CityId' cannot be null.");
    else content_.append('Location.CityId', location_CityId.toString());
    if (location_RegionId === null || location_RegionId === undefined)
      throw new Error("The parameter 'location_RegionId' cannot be null.");
    else content_.append('Location.RegionId', location_RegionId.toString());
    if (location_ParentSubRegionId !== null && location_ParentSubRegionId !== undefined)
      content_.append(
        'Location.ParentSubRegionId',
        location_ParentSubRegionId.toString()
      );
    if (location_SubRegionId !== null && location_SubRegionId !== undefined)
      content_.append('Location.SubRegionId', location_SubRegionId.toString());
    if (location_Longitude === null || location_Longitude === undefined)
      throw new Error("The parameter 'location_Longitude' cannot be null.");
    else content_.append('Location.Longitude', location_Longitude.toString());
    if (location_Latitude === null || location_Latitude === undefined)
      throw new Error("The parameter 'location_Latitude' cannot be null.");
    else content_.append('Location.Latitude', location_Latitude.toString());
    if (sellingDetails_PaymentType === null || sellingDetails_PaymentType === undefined)
      throw new Error("The parameter 'sellingDetails_PaymentType' cannot be null.");
    else
      content_.append(
        'SellingDetails.PaymentType',
        sellingDetails_PaymentType.toString()
      );
    if (sellingDetails_Price === null || sellingDetails_Price === undefined)
      throw new Error("The parameter 'sellingDetails_Price' cannot be null.");
    else content_.append('SellingDetails.Price', sellingDetails_Price.toString());
    if (sellingDetails_FirstBatch !== null && sellingDetails_FirstBatch !== undefined)
      content_.append('SellingDetails.FirstBatch', sellingDetails_FirstBatch.toString());
    if (sellingDetails_Remaining !== null && sellingDetails_Remaining !== undefined)
      content_.append('SellingDetails.Remaining', sellingDetails_Remaining.toString());
    if (
      sellingDetails_InstallmentYears !== null &&
      sellingDetails_InstallmentYears !== undefined
    )
      content_.append(
        'SellingDetails.InstallmentYears',
        sellingDetails_InstallmentYears.toString()
      );
    if (sellingDetails_IsNegotiable === null || sellingDetails_IsNegotiable === undefined)
      throw new Error("The parameter 'sellingDetails_IsNegotiable' cannot be null.");
    else
      content_.append(
        'SellingDetails.IsNegotiable',
        sellingDetails_IsNegotiable.toString()
      );
    if (
      sellingDetails_IncludesMaintenanceDeposit === null ||
      sellingDetails_IncludesMaintenanceDeposit === undefined
    )
      throw new Error(
        "The parameter 'sellingDetails_IncludesMaintenanceDeposit' cannot be null."
      );
    else
      content_.append(
        'SellingDetails.IncludesMaintenanceDeposit',
        sellingDetails_IncludesMaintenanceDeposit.toString()
      );
    if (rentingDetails_PeriodType === null || rentingDetails_PeriodType === undefined)
      throw new Error("The parameter 'rentingDetails_PeriodType' cannot be null.");
    else
      content_.append('RentingDetails.PeriodType', rentingDetails_PeriodType.toString());
    if (rentingDetails_PeriodRange === null || rentingDetails_PeriodRange === undefined)
      throw new Error("The parameter 'rentingDetails_PeriodRange' cannot be null.");
    else
      content_.append(
        'RentingDetails.PeriodRange',
        rentingDetails_PeriodRange.toString()
      );
    if (rentingDetails_Price === null || rentingDetails_Price === undefined)
      throw new Error("The parameter 'rentingDetails_Price' cannot be null.");
    else content_.append('RentingDetails.Price', rentingDetails_Price.toString());
    if (
      rentingDetails_AnnualIncreaseRate === null ||
      rentingDetails_AnnualIncreaseRate === undefined
    )
      throw new Error(
        "The parameter 'rentingDetails_AnnualIncreaseRate' cannot be null."
      );
    else
      content_.append(
        'RentingDetails.AnnualIncreaseRate',
        rentingDetails_AnnualIncreaseRate.toString()
      );
    if (
      rentingDetails_AnnualIncreaseValue === null ||
      rentingDetails_AnnualIncreaseValue === undefined
    )
      throw new Error(
        "The parameter 'rentingDetails_AnnualIncreaseValue' cannot be null."
      );
    else
      content_.append(
        'RentingDetails.AnnualIncreaseValue',
        rentingDetails_AnnualIncreaseValue.toString()
      );
    if (
      rentingDetails_MaintenanceType === null ||
      rentingDetails_MaintenanceType === undefined
    )
      throw new Error("The parameter 'rentingDetails_MaintenanceType' cannot be null.");
    else
      content_.append(
        'RentingDetails.MaintenanceType',
        rentingDetails_MaintenanceType.toString()
      );
    if (
      rentingDetails_InsuranceType === null ||
      rentingDetails_InsuranceType === undefined
    )
      throw new Error("The parameter 'rentingDetails_InsuranceType' cannot be null.");
    else
      content_.append(
        'RentingDetails.InsuranceType',
        rentingDetails_InsuranceType.toString()
      );
    if (
      rentingDetails_MaintenanceValue === null ||
      rentingDetails_MaintenanceValue === undefined
    )
      throw new Error("The parameter 'rentingDetails_MaintenanceValue' cannot be null.");
    else
      content_.append(
        'RentingDetails.MaintenanceValue',
        rentingDetails_MaintenanceValue.toString()
      );
    if (
      rentingDetails_InsuranceValue === null ||
      rentingDetails_InsuranceValue === undefined
    )
      throw new Error("The parameter 'rentingDetails_InsuranceValue' cannot be null.");
    else
      content_.append(
        'RentingDetails.InsuranceValue',
        rentingDetails_InsuranceValue.toString()
      );
    if (size === null || size === undefined)
      throw new Error("The parameter 'size' cannot be null.");
    else content_.append('Size', size.toString());
    if (netSize !== null && netSize !== undefined)
      content_.append('NetSize', netSize.toString());
    if (ownerRelation === null || ownerRelation === undefined)
      throw new Error("The parameter 'ownerRelation' cannot be null.");
    else content_.append('OwnerRelation', ownerRelation.toString());
    if (categoryId === null || categoryId === undefined)
      throw new Error("The parameter 'categoryId' cannot be null.");
    else content_.append('CategoryId', categoryId.toString());
    if (attachments !== null && attachments !== undefined)
      attachments.forEach((item_) => content_.append('Attachments', item_.toString()));
    if (categories !== null && categories !== undefined)
      categories.forEach((item_) => content_.append('Categories', item_.toString()));
    if (cities !== null && cities !== undefined)
      cities.forEach((item_) => content_.append('Cities', item_.toString()));
    if (places !== null && places !== undefined)
      places.forEach((item_) => content_.append('Places', item_.toString()));
    if (certifications !== null && certifications !== undefined)
      certifications.forEach((item_) =>
        content_.append('Certifications', item_.toString())
      );

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  delete(postId: string | null | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/Posts?';
    if (postId !== undefined && postId !== null)
      url_ += 'postId=' + encodeURIComponent('' + postId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  putStatus(command: PostsPutStatusCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/Posts/PutStatus';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPutStatus(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPutStatus(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPutStatus(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  deleteAttachment(
    postId: string | null | undefined,
    attachmentId: number | undefined
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/Posts/DeleteAttachment?';
    if (postId !== undefined && postId !== null)
      url_ += 'postId=' + encodeURIComponent('' + postId) + '&';
    if (attachmentId === null)
      throw new Error("The parameter 'attachmentId' cannot be null.");
    else if (attachmentId !== undefined)
      url_ += 'attachmentId=' + encodeURIComponent('' + attachmentId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteAttachment(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteAttachment(<any>response_);
            } catch (e) {
              return <Observable<FileResponse>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteAttachment(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return _observableOf({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<FileResponse>(<any>null);
  }

  close(command: PostsCloseCommand): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/Posts/Close';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processClose(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processClose(<any>response_);
            } catch (e) {
              return <Observable<FileResponse>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processClose(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return _observableOf({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<FileResponse>(<any>null);
  }
}

export interface IPrivacyPoliciesClient {
  get(): Observable<PrivacyPolicyVm>;
  put(command: PrivacyPoliciesPutCommand): Observable<void>;
  getForDashboard(lang: Language | undefined): Observable<PrivacyPolicyDto>;
}

@Injectable({
  providedIn: 'root',
})
export class PrivacyPoliciesClient implements IPrivacyPoliciesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  get(): Observable<PrivacyPolicyVm> {
    let url_ = this.baseUrl + '/api/PrivacyPolicies';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<PrivacyPolicyVm>>(<any>_observableThrow(e));
            }
          } else return <Observable<PrivacyPolicyVm>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<PrivacyPolicyVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PrivacyPolicyVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  put(command: PrivacyPoliciesPutCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/PrivacyPolicies';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getForDashboard(lang: Language | undefined): Observable<PrivacyPolicyDto> {
    let url_ = this.baseUrl + '/api/PrivacyPolicies/GetForDashboard?';
    if (lang === null) throw new Error("The parameter 'lang' cannot be null.");
    else if (lang !== undefined) url_ += 'Lang=' + encodeURIComponent('' + lang) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetForDashboard(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetForDashboard(<any>response_);
            } catch (e) {
              return <Observable<PrivacyPolicyDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<PrivacyPolicyDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetForDashboard(
    response: HttpResponseBase
  ): Observable<PrivacyPolicyDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PrivacyPolicyDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IRegionsClient {
  getList(subRegionId: number | null | undefined): Observable<RegionDashboardVm[]>;
  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfRegionDto>;
  post(
    name_Ar: string | null | undefined,
    name_En: string | null | undefined,
    video: FileParameter | null | undefined,
    isSupported: boolean | undefined,
    cityId: number | undefined
  ): Observable<HttpResultOfInteger>;
  put(
    id: number | undefined,
    name_Ar: string | null | undefined,
    name_En: string | null | undefined,
    video: FileParameter | null | undefined,
    isSupported: boolean | undefined,
    cityId: number | undefined
  ): Observable<void>;
  delete(id: number | undefined): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class RegionsClient implements IRegionsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getList(subRegionId: number | null | undefined): Observable<RegionDashboardVm[]> {
    let url_ = this.baseUrl + '/api/Regions/GetList?';
    if (subRegionId !== undefined && subRegionId !== null)
      url_ += 'subRegionId=' + encodeURIComponent('' + subRegionId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetList(<any>response_);
            } catch (e) {
              return <Observable<RegionDashboardVm[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<RegionDashboardVm[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetList(response: HttpResponseBase): Observable<RegionDashboardVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(RegionDashboardVm.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfRegionDto> {
    let url_ = this.baseUrl + '/api/Regions/GetPage?';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(<any>response_);
            } catch (e) {
              return <Observable<PaginatedListOfRegionDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<PaginatedListOfRegionDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfRegionDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfRegionDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  post(
    name_Ar: string | null | undefined,
    name_En: string | null | undefined,
    video: FileParameter | null | undefined,
    isSupported: boolean | undefined,
    cityId: number | undefined
  ): Observable<HttpResultOfInteger> {
    let url_ = this.baseUrl + '/api/Regions';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = new FormData();
    if (name_Ar !== null && name_Ar !== undefined)
      content_.append('Name.Ar', name_Ar.toString());
    if (name_En !== null && name_En !== undefined)
      content_.append('Name.En', name_En.toString());
    if (video !== null && video !== undefined)
      content_.append('Video', video.data, video.fileName ? video.fileName : 'Video');
    if (isSupported === null || isSupported === undefined)
      throw new Error("The parameter 'isSupported' cannot be null.");
    else content_.append('IsSupported', isSupported.toString());
    if (cityId === null || cityId === undefined)
      throw new Error("The parameter 'cityId' cannot be null.");
    else content_.append('CityId', cityId.toString());

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPost(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPost(<any>response_);
            } catch (e) {
              return <Observable<HttpResultOfInteger>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<HttpResultOfInteger>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPost(response: HttpResponseBase): Observable<HttpResultOfInteger> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfInteger.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  put(
    id: number | undefined,
    name_Ar: string | null | undefined,
    name_En: string | null | undefined,
    video: FileParameter | null | undefined,
    isSupported: boolean | undefined,
    cityId: number | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/Regions';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = new FormData();
    if (id === null || id === undefined)
      throw new Error("The parameter 'id' cannot be null.");
    else content_.append('Id', id.toString());
    if (name_Ar !== null && name_Ar !== undefined)
      content_.append('Name.Ar', name_Ar.toString());
    if (name_En !== null && name_En !== undefined)
      content_.append('Name.En', name_En.toString());
    if (video !== null && video !== undefined)
      content_.append('Video', video.data, video.fileName ? video.fileName : 'Video');
    if (isSupported === null || isSupported === undefined)
      throw new Error("The parameter 'isSupported' cannot be null.");
    else content_.append('IsSupported', isSupported.toString());
    if (cityId === null || cityId === undefined)
      throw new Error("The parameter 'cityId' cannot be null.");
    else content_.append('CityId', cityId.toString());

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/Regions?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IServicesClient {
  get(
    regionId: number | undefined,
    subRegionId: number | null | undefined
  ): Observable<ServiceVm[]>;
  post(command: ServicesPostCommand): Observable<HttpResultOfInteger>;
  put(command: ServicesPutCommand): Observable<void>;
  delete(id: number | undefined): Observable<void>;
  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfServiceDto>;
}

@Injectable({
  providedIn: 'root',
})
export class ServicesClient implements IServicesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  get(
    regionId: number | undefined,
    subRegionId: number | null | undefined
  ): Observable<ServiceVm[]> {
    let url_ = this.baseUrl + '/api/Services?';
    if (regionId === null) throw new Error("The parameter 'regionId' cannot be null.");
    else if (regionId !== undefined)
      url_ += 'regionId=' + encodeURIComponent('' + regionId) + '&';
    if (subRegionId !== undefined && subRegionId !== null)
      url_ += 'subRegionId=' + encodeURIComponent('' + subRegionId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<ServiceVm[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<ServiceVm[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<ServiceVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ServiceVm.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ServiceVm[]>(<any>null);
  }

  post(command: ServicesPostCommand): Observable<HttpResultOfInteger> {
    let url_ = this.baseUrl + '/api/Services';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPost(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPost(<any>response_);
            } catch (e) {
              return <Observable<HttpResultOfInteger>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<HttpResultOfInteger>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPost(response: HttpResponseBase): Observable<HttpResultOfInteger> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfInteger.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  put(command: ServicesPutCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/Services';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/Services?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfServiceDto> {
    let url_ = this.baseUrl + '/api/Services/GetPage?';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(<any>response_);
            } catch (e) {
              return <Observable<PaginatedListOfServiceDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<PaginatedListOfServiceDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfServiceDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfServiceDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IServiceTypesClient {
  getList(): Observable<ServiceTypeVm[]>;
  getPage(): Observable<ServiceTypeDto[]>;
  post(command: ServiceTypesPostCommand): Observable<HttpResultOfInteger>;
  put(command: ServiceTypesPutCommand): Observable<void>;
  delete(id: number | undefined): Observable<void>;
  putOrder(command: ServiceTypesPutOrderCommand): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class ServiceTypesClient implements IServiceTypesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getList(): Observable<ServiceTypeVm[]> {
    let url_ = this.baseUrl + '/api/ServiceTypes/GetList';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetList(<any>response_);
            } catch (e) {
              return <Observable<ServiceTypeVm[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<ServiceTypeVm[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetList(response: HttpResponseBase): Observable<ServiceTypeVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ServiceTypeVm.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getPage(): Observable<ServiceTypeDto[]> {
    let url_ = this.baseUrl + '/api/ServiceTypes/GetPage';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(<any>response_);
            } catch (e) {
              return <Observable<ServiceTypeDto[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<ServiceTypeDto[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetPage(response: HttpResponseBase): Observable<ServiceTypeDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ServiceTypeDto.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  post(command: ServiceTypesPostCommand): Observable<HttpResultOfInteger> {
    let url_ = this.baseUrl + '/api/ServiceTypes';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPost(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPost(<any>response_);
            } catch (e) {
              return <Observable<HttpResultOfInteger>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<HttpResultOfInteger>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPost(response: HttpResponseBase): Observable<HttpResultOfInteger> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfInteger.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  put(command: ServiceTypesPutCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/ServiceTypes';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/ServiceTypes?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  putOrder(command: ServiceTypesPutOrderCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/ServiceTypes/PutOrder';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPutOrder(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPutOrder(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPutOrder(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface ISubRegionsClient {
  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfSubRegionDto>;
  post(command: SubRegionsPostCommand): Observable<HttpResultOfInteger>;
  put(command: SubRegionsPutCommand): Observable<void>;
  delete(id: number | undefined): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class SubRegionsClient implements ISubRegionsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfSubRegionDto> {
    let url_ = this.baseUrl + '/api/SubRegions/GetPage?';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(<any>response_);
            } catch (e) {
              return <Observable<PaginatedListOfSubRegionDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<PaginatedListOfSubRegionDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfSubRegionDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfSubRegionDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  post(command: SubRegionsPostCommand): Observable<HttpResultOfInteger> {
    let url_ = this.baseUrl + '/api/SubRegions';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPost(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPost(<any>response_);
            } catch (e) {
              return <Observable<HttpResultOfInteger>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<HttpResultOfInteger>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPost(response: HttpResponseBase): Observable<HttpResultOfInteger> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfInteger.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  put(command: SubRegionsPutCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/SubRegions';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/SubRegions?';
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface ITransactionsClient {
  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfTransactionVm>;
}

@Injectable({
  providedIn: 'root',
})
export class TransactionsClient implements ITransactionsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined
  ): Observable<PaginatedListOfTransactionVm> {
    let url_ = this.baseUrl + '/api/Transactions/GetPage?';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(<any>response_);
            } catch (e) {
              return <Observable<PaginatedListOfTransactionVm>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<PaginatedListOfTransactionVm>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfTransactionVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfTransactionVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export class ProblemDetails implements IProblemDetails {
  type?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;
  extensions?: { [key: string]: any } | undefined;

  constructor(data?: IProblemDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.type = _data['type'];
      this.title = _data['title'];
      this.status = _data['status'];
      this.detail = _data['detail'];
      this.instance = _data['instance'];
      if (_data['extensions']) {
        this.extensions = {} as any;
        for (let key in _data['extensions']) {
          if (_data['extensions'].hasOwnProperty(key))
            this.extensions![key] = _data['extensions'][key];
        }
      }
    }
  }

  static fromJS(data: any): ProblemDetails {
    data = typeof data === 'object' ? data : {};
    let result = new ProblemDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['type'] = this.type;
    data['title'] = this.title;
    data['status'] = this.status;
    data['detail'] = this.detail;
    data['instance'] = this.instance;
    if (this.extensions) {
      data['extensions'] = {};
      for (let key in this.extensions) {
        if (this.extensions.hasOwnProperty(key))
          data['extensions'][key] = this.extensions[key];
      }
    }
    return data;
  }
}

export interface IProblemDetails {
  type?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;
  extensions?: { [key: string]: any } | undefined;
}

export class PaginatedListOfAccountVm implements IPaginatedListOfAccountVm {
  pageInfo?: PageInfo | undefined;
  items?: AccountVm[] | undefined;

  constructor(data?: IPaginatedListOfAccountVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(AccountVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfAccountVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfAccountVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfAccountVm {
  pageInfo?: PageInfo | undefined;
  items?: AccountVm[] | undefined;
}

export class PageInfo implements IPageInfo {
  pageIndex?: number;
  totalPages?: number;
  totalCount?: number;

  constructor(data?: IPageInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageIndex = _data['pageIndex'];
      this.totalPages = _data['totalPages'];
      this.totalCount = _data['totalCount'];
    }
  }

  static fromJS(data: any): PageInfo {
    data = typeof data === 'object' ? data : {};
    let result = new PageInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageIndex'] = this.pageIndex;
    data['totalPages'] = this.totalPages;
    data['totalCount'] = this.totalCount;
    return data;
  }
}

export interface IPageInfo {
  pageIndex?: number;
  totalPages?: number;
  totalCount?: number;
}

export class AccountVm implements IAccountVm {
  id?: string | undefined;
  username?: string | undefined;
  fullName?: string | undefined;
  pictureUrl?: string | undefined;
  phoneNumber?: string | undefined;
  type?: AccountType;
  status?: AccountStatus;

  constructor(data?: IAccountVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.username = _data['username'];
      this.fullName = _data['fullName'];
      this.pictureUrl = _data['pictureUrl'];
      this.phoneNumber = _data['phoneNumber'];
      this.type = _data['type'];
      this.status = _data['status'];
    }
  }

  static fromJS(data: any): AccountVm {
    data = typeof data === 'object' ? data : {};
    let result = new AccountVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['username'] = this.username;
    data['fullName'] = this.fullName;
    data['pictureUrl'] = this.pictureUrl;
    data['phoneNumber'] = this.phoneNumber;
    data['type'] = this.type;
    data['status'] = this.status;
    return data;
  }
}

export interface IAccountVm {
  id?: string | undefined;
  username?: string | undefined;
  fullName?: string | undefined;
  pictureUrl?: string | undefined;
  phoneNumber?: string | undefined;
  type?: AccountType;
  status?: AccountStatus;
}

/** 0 = Regular 1 = DevelopmentCompany 2 = RealEstateAgent 3 = ShoppingCompany */
export enum AccountType {
  Regular = 0,
  DevelopmentCompany = 1,
  RealEstateAgent = 2,
  ShoppingCompany = 3,
}

/** 0 = Live 1 = Banned */
export enum AccountStatus {
  Live = 0,
  Banned = 1,
}

export class ValidationProblemDetails
  extends ProblemDetails
  implements IValidationProblemDetails {
  errors?: { [key: string]: string[] } | undefined;

  constructor(data?: IValidationProblemDetails) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      if (_data['errors']) {
        this.errors = {} as any;
        for (let key in _data['errors']) {
          if (_data['errors'].hasOwnProperty(key))
            this.errors![key] =
              _data['errors'][key] !== undefined ? _data['errors'][key] : [];
        }
      }
    }
  }

  static fromJS(data: any): ValidationProblemDetails {
    data = typeof data === 'object' ? data : {};
    let result = new ValidationProblemDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.errors) {
      data['errors'] = {};
      for (let key in this.errors) {
        if (this.errors.hasOwnProperty(key)) data['errors'][key] = this.errors[key];
      }
    }
    super.toJSON(data);
    return data;
  }
}

export interface IValidationProblemDetails extends IProblemDetails {
  errors?: { [key: string]: string[] } | undefined;
}

/** 0 = Admin 1 = User 2 = Certifier 3 = DataEntry 4 = CustomerSupport 5 = Accountant */
export enum Role {
  Admin = 0,
  User = 1,
  Certifier = 2,
  DataEntry = 3,
  CustomerSupport = 4,
  Accountant = 5,
}

export class HttpResultOfString implements IHttpResultOfString {
  result?: string | undefined;

  constructor(data?: IHttpResultOfString) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.result = _data['result'];
    }
  }

  static fromJS(data: any): HttpResultOfString {
    data = typeof data === 'object' ? data : {};
    let result = new HttpResultOfString();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['result'] = this.result;
    return data;
  }
}

export interface IHttpResultOfString {
  result?: string | undefined;
}

export class LoginCommand implements ILoginCommand {
  email!: string;
  password!: string;

  constructor(data?: ILoginCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email'];
      this.password = _data['password'];
    }
  }

  static fromJS(data: any): LoginCommand {
    data = typeof data === 'object' ? data : {};
    let result = new LoginCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    data['password'] = this.password;
    return data;
  }
}

export interface ILoginCommand {
  email: string;
  password: string;
}

export class ExternalLoginCommand implements IExternalLoginCommand {
  provider!: string;
  token!: string;

  constructor(data?: IExternalLoginCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.provider = _data['provider'];
      this.token = _data['token'];
    }
  }

  static fromJS(data: any): ExternalLoginCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ExternalLoginCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['provider'] = this.provider;
    data['token'] = this.token;
    return data;
  }
}

export interface IExternalLoginCommand {
  provider: string;
  token: string;
}

export class UserPostCommon implements IUserPostCommon {
  phoneNumber?: string | undefined;

  constructor(data?: IUserPostCommon) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.phoneNumber = _data['phoneNumber'];
    }
  }

  static fromJS(data: any): UserPostCommon {
    data = typeof data === 'object' ? data : {};
    let result = new UserPostCommon();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['phoneNumber'] = this.phoneNumber;
    return data;
  }
}

export interface IUserPostCommon {
  phoneNumber?: string | undefined;
}

export class ExternalRegisterCommand
  extends UserPostCommon
  implements IExternalRegisterCommand {
  provider?: string | undefined;
  token?: string | undefined;

  constructor(data?: IExternalRegisterCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.provider = _data['provider'];
      this.token = _data['token'];
    }
  }

  static fromJS(data: any): ExternalRegisterCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ExternalRegisterCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['provider'] = this.provider;
    data['token'] = this.token;
    super.toJSON(data);
    return data;
  }
}

export interface IExternalRegisterCommand extends IUserPostCommon {
  provider?: string | undefined;
  token?: string | undefined;
}

export class AccountsPostCommand extends UserPostCommon implements IAccountsPostCommand {
  email?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
  name?: FullNameDto | undefined;
  type?: AccountType;
  role?: Role;

  constructor(data?: IAccountsPostCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.email = _data['email'];
      this.password = _data['password'];
      this.confirmPassword = _data['confirmPassword'];
      this.name = _data['name'] ? FullNameDto.fromJS(_data['name']) : <any>undefined;
      this.type = _data['type'];
      this.role = _data['role'];
    }
  }

  static fromJS(data: any): AccountsPostCommand {
    data = typeof data === 'object' ? data : {};
    let result = new AccountsPostCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    data['password'] = this.password;
    data['confirmPassword'] = this.confirmPassword;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['type'] = this.type;
    data['role'] = this.role;
    super.toJSON(data);
    return data;
  }
}

export interface IAccountsPostCommand extends IUserPostCommon {
  email?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
  name?: FullNameDto | undefined;
  type?: AccountType;
  role?: Role;
}

export class FullNameDto implements IFullNameDto {
  firstName?: string | undefined;
  lastName?: string | undefined;

  constructor(data?: IFullNameDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.firstName = _data['firstName'];
      this.lastName = _data['lastName'];
    }
  }

  static fromJS(data: any): FullNameDto {
    data = typeof data === 'object' ? data : {};
    let result = new FullNameDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['firstName'] = this.firstName;
    data['lastName'] = this.lastName;
    return data;
  }
}

export interface IFullNameDto {
  firstName?: string | undefined;
  lastName?: string | undefined;
}

export class ChangePasswordCommand implements IChangePasswordCommand {
  accountId?: string | undefined;
  oldPassword!: string;
  newPassword!: string;

  constructor(data?: IChangePasswordCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.accountId = _data['accountId'];
      this.oldPassword = _data['oldPassword'];
      this.newPassword = _data['newPassword'];
    }
  }

  static fromJS(data: any): ChangePasswordCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ChangePasswordCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['accountId'] = this.accountId;
    data['oldPassword'] = this.oldPassword;
    data['newPassword'] = this.newPassword;
    return data;
  }
}

export interface IChangePasswordCommand {
  accountId?: string | undefined;
  oldPassword: string;
  newPassword: string;
}

export class ChangePhoneNumberCommand implements IChangePhoneNumberCommand {
  phoneNumber!: string;

  constructor(data?: IChangePhoneNumberCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.phoneNumber = _data['phoneNumber'];
    }
  }

  static fromJS(data: any): ChangePhoneNumberCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ChangePhoneNumberCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['phoneNumber'] = this.phoneNumber;
    return data;
  }
}

export interface IChangePhoneNumberCommand {
  phoneNumber: string;
}

export class AccountsPutRoleCommand implements IAccountsPutRoleCommand {
  id!: string;
  role?: Role;

  constructor(data?: IAccountsPutRoleCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.role = _data['role'];
    }
  }

  static fromJS(data: any): AccountsPutRoleCommand {
    data = typeof data === 'object' ? data : {};
    let result = new AccountsPutRoleCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['role'] = this.role;
    return data;
  }
}

export interface IAccountsPutRoleCommand {
  id: string;
  role?: Role;
}

export class AccountsBanCommand implements IAccountsBanCommand {
  id!: string;
  reason!: LocalizedStringDto;

  constructor(data?: IAccountsBanCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.reason = new LocalizedStringDto();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.reason = _data['reason']
        ? LocalizedStringDto.fromJS(_data['reason'])
        : new LocalizedStringDto();
    }
  }

  static fromJS(data: any): AccountsBanCommand {
    data = typeof data === 'object' ? data : {};
    let result = new AccountsBanCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['reason'] = this.reason ? this.reason.toJSON() : <any>undefined;
    return data;
  }
}

export interface IAccountsBanCommand {
  id: string;
  reason: LocalizedStringDto;
}

export class LocalizedStringDto implements ILocalizedStringDto {
  ar?: string | undefined;
  en?: string | undefined;

  constructor(data?: ILocalizedStringDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.ar = _data['ar'];
      this.en = _data['en'];
    }
  }

  static fromJS(data: any): LocalizedStringDto {
    data = typeof data === 'object' ? data : {};
    let result = new LocalizedStringDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['ar'] = this.ar;
    data['en'] = this.en;
    return data;
  }
}

export interface ILocalizedStringDto {
  ar?: string | undefined;
  en?: string | undefined;
}

export class AdVm implements IAdVm {
  bannerUrl?: string | undefined;
  targetUrl?: string | undefined;

  constructor(data?: IAdVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.bannerUrl = _data['bannerUrl'];
      this.targetUrl = _data['targetUrl'];
    }
  }

  static fromJS(data: any): AdVm {
    data = typeof data === 'object' ? data : {};
    let result = new AdVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['bannerUrl'] = this.bannerUrl;
    data['targetUrl'] = this.targetUrl;
    return data;
  }
}

export interface IAdVm {
  bannerUrl?: string | undefined;
  targetUrl?: string | undefined;
}

export class PaginatedListOfAdDashboardVm implements IPaginatedListOfAdDashboardVm {
  pageInfo?: PageInfo | undefined;
  items?: AdDashboardVm[] | undefined;

  constructor(data?: IPaginatedListOfAdDashboardVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(AdDashboardVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfAdDashboardVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfAdDashboardVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfAdDashboardVm {
  pageInfo?: PageInfo | undefined;
  items?: AdDashboardVm[] | undefined;
}

export class AdDashboardVm implements IAdDashboardVm {
  id?: number;
  title?: string | undefined;
  endAt?: Date;
  isLive?: boolean;

  constructor(data?: IAdDashboardVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.title = _data['title'];
      this.endAt = _data['endAt'] ? new Date(_data['endAt'].toString()) : <any>undefined;
      this.isLive = _data['isLive'];
    }
  }

  static fromJS(data: any): AdDashboardVm {
    data = typeof data === 'object' ? data : {};
    let result = new AdDashboardVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['title'] = this.title;
    data['endAt'] = this.endAt ? this.endAt.toISOString() : <any>undefined;
    data['isLive'] = this.isLive;
    return data;
  }
}

export interface IAdDashboardVm {
  id?: number;
  title?: string | undefined;
  endAt?: Date;
  isLive?: boolean;
}

export class AdDto implements IAdDto {
  id?: number;
  title?: LocalizedStringDto | undefined;
  bannerUrl?: string | undefined;
  content?: string | undefined;
  targetUrl?: string | undefined;
  endAt?: Date;
  isLive?: boolean;
  type?: AdType;

  constructor(data?: IAdDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.title = _data['title']
        ? LocalizedStringDto.fromJS(_data['title'])
        : <any>undefined;
      this.bannerUrl = _data['bannerUrl'];
      this.content = _data['content'];
      this.targetUrl = _data['targetUrl'];
      this.endAt = _data['endAt'] ? new Date(_data['endAt'].toString()) : <any>undefined;
      this.isLive = _data['isLive'];
      this.type = _data['type'];
    }
  }

  static fromJS(data: any): AdDto {
    data = typeof data === 'object' ? data : {};
    let result = new AdDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['title'] = this.title ? this.title.toJSON() : <any>undefined;
    data['bannerUrl'] = this.bannerUrl;
    data['content'] = this.content;
    data['targetUrl'] = this.targetUrl;
    data['endAt'] = this.endAt ? this.endAt.toISOString() : <any>undefined;
    data['isLive'] = this.isLive;
    data['type'] = this.type;
    return data;
  }
}

export interface IAdDto {
  id?: number;
  title?: LocalizedStringDto | undefined;
  bannerUrl?: string | undefined;
  content?: string | undefined;
  targetUrl?: string | undefined;
  endAt?: Date;
  isLive?: boolean;
  type?: AdType;
}

/** 0 = Campaign 1 = Advertisement */
export enum AdType {
  Campaign = 0,
  Advertisement = 1,
}

export class HttpResultOfInteger implements IHttpResultOfInteger {
  result?: number;

  constructor(data?: IHttpResultOfInteger) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.result = _data['result'];
    }
  }

  static fromJS(data: any): HttpResultOfInteger {
    data = typeof data === 'object' ? data : {};
    let result = new HttpResultOfInteger();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['result'] = this.result;
    return data;
  }
}

export interface IHttpResultOfInteger {
  result?: number;
}

export class GroupingOfCategoryVm implements IGroupingOfCategoryVm {
  key?: number;
  items?: CategoryVm[] | undefined;

  constructor(data?: IGroupingOfCategoryVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.key = _data['key'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(CategoryVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GroupingOfCategoryVm {
    data = typeof data === 'object' ? data : {};
    let result = new GroupingOfCategoryVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['key'] = this.key;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IGroupingOfCategoryVm {
  key?: number;
  items?: CategoryVm[] | undefined;
}

export class CategoryVm implements ICategoryVm {
  id?: number;
  permaKey?: string | undefined;
  name?: string | undefined;
  svgUrl?: string | undefined;
  isDisabled?: boolean;
  subCategories?: CategoryVm[] | undefined;

  constructor(data?: ICategoryVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.permaKey = _data['permaKey'];
      this.name = _data['name'];
      this.svgUrl = _data['svgUrl'];
      this.isDisabled = _data['isDisabled'];
      if (Array.isArray(_data['subCategories'])) {
        this.subCategories = [] as any;
        for (let item of _data['subCategories'])
          this.subCategories!.push(CategoryVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): CategoryVm {
    data = typeof data === 'object' ? data : {};
    let result = new CategoryVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['permaKey'] = this.permaKey;
    data['name'] = this.name;
    data['svgUrl'] = this.svgUrl;
    data['isDisabled'] = this.isDisabled;
    if (Array.isArray(this.subCategories)) {
      data['subCategories'] = [];
      for (let item of this.subCategories) data['subCategories'].push(item.toJSON());
    }
    return data;
  }
}

export interface ICategoryVm {
  id?: number;
  permaKey?: string | undefined;
  name?: string | undefined;
  svgUrl?: string | undefined;
  isDisabled?: boolean;
  subCategories?: CategoryVm[] | undefined;
}

export class PaginatedListOfCategoryDashboardVm
  implements IPaginatedListOfCategoryDashboardVm {
  pageInfo?: PageInfo | undefined;
  items?: CategoryDashboardVm[] | undefined;

  constructor(data?: IPaginatedListOfCategoryDashboardVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items'])
          this.items!.push(CategoryDashboardVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfCategoryDashboardVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfCategoryDashboardVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfCategoryDashboardVm {
  pageInfo?: PageInfo | undefined;
  items?: CategoryDashboardVm[] | undefined;
}

export class CategoryDashboardVm implements ICategoryDashboardVm {
  id?: number;
  name?: string | undefined;
  type?: CategoryType;
  isDisabled?: boolean;
  isGroupCategory?: boolean;

  constructor(data?: ICategoryDashboardVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.type = _data['type'];
      this.isDisabled = _data['isDisabled'];
      this.isGroupCategory = _data['isGroupCategory'];
    }
  }

  static fromJS(data: any): CategoryDashboardVm {
    data = typeof data === 'object' ? data : {};
    let result = new CategoryDashboardVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['type'] = this.type;
    data['isDisabled'] = this.isDisabled;
    data['isGroupCategory'] = this.isGroupCategory;
    return data;
  }
}

export interface ICategoryDashboardVm {
  id?: number;
  name?: string | undefined;
  type?: CategoryType;
  isDisabled?: boolean;
  isGroupCategory?: boolean;
}

/** 0 = Residential 1 = NonResidential */
export enum CategoryType {
  Residential = 0,
  NonResidential = 1,
}

export class CategoryDto implements ICategoryDto {
  id?: number;
  name?: LocalizedStringDto | undefined;
  type?: CategoryType;
  svgUrl?: string | undefined;
  isDisabled?: boolean;
  dependant?: boolean;
  groupCategoryId?: number | undefined;

  constructor(data?: ICategoryDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.type = _data['type'];
      this.svgUrl = _data['svgUrl'];
      this.isDisabled = _data['isDisabled'];
      this.dependant = _data['dependant'];
      this.groupCategoryId = _data['groupCategoryId'];
    }
  }

  static fromJS(data: any): CategoryDto {
    data = typeof data === 'object' ? data : {};
    let result = new CategoryDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['type'] = this.type;
    data['svgUrl'] = this.svgUrl;
    data['isDisabled'] = this.isDisabled;
    data['dependant'] = this.dependant;
    data['groupCategoryId'] = this.groupCategoryId;
    return data;
  }
}

export interface ICategoryDto {
  id?: number;
  name?: LocalizedStringDto | undefined;
  type?: CategoryType;
  svgUrl?: string | undefined;
  isDisabled?: boolean;
  dependant?: boolean;
  groupCategoryId?: number | undefined;
}

export class CertificationDataDto implements ICertificationDataDto {
  id?: number;
  price?: number;
  isAvailable?: boolean;

  constructor(data?: ICertificationDataDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.price = _data['price'];
      this.isAvailable = _data['isAvailable'];
    }
  }

  static fromJS(data: any): CertificationDataDto {
    data = typeof data === 'object' ? data : {};
    let result = new CertificationDataDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['price'] = this.price;
    data['isAvailable'] = this.isAvailable;
    return data;
  }
}

export interface ICertificationDataDto {
  id?: number;
  price?: number;
  isAvailable?: boolean;
}

export class PaginatedListOfCertificationVm implements IPaginatedListOfCertificationVm {
  pageInfo?: PageInfo | undefined;
  items?: CertificationVm[] | undefined;

  constructor(data?: IPaginatedListOfCertificationVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(CertificationVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfCertificationVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfCertificationVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfCertificationVm {
  pageInfo?: PageInfo | undefined;
  items?: CertificationVm[] | undefined;
}

export class CertificationVm implements ICertificationVm {
  postId?: string | undefined;
  postTitle?: string | undefined;
  requestedAt?: Date;
  certifiedAt?: Date | undefined;
  type?: CertificationType;
  status?: CertificationStatus;
  certifierName?: string | undefined;

  constructor(data?: ICertificationVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.postId = _data['postId'];
      this.postTitle = _data['postTitle'];
      this.requestedAt = _data['requestedAt']
        ? new Date(_data['requestedAt'].toString())
        : <any>undefined;
      this.certifiedAt = _data['certifiedAt']
        ? new Date(_data['certifiedAt'].toString())
        : <any>undefined;
      this.type = _data['type'];
      this.status = _data['status'];
      this.certifierName = _data['certifierName'];
    }
  }

  static fromJS(data: any): CertificationVm {
    data = typeof data === 'object' ? data : {};
    let result = new CertificationVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['postId'] = this.postId;
    data['postTitle'] = this.postTitle;
    data['requestedAt'] = this.requestedAt
      ? this.requestedAt.toISOString()
      : <any>undefined;
    data['certifiedAt'] = this.certifiedAt
      ? this.certifiedAt.toISOString()
      : <any>undefined;
    data['type'] = this.type;
    data['status'] = this.status;
    data['certifierName'] = this.certifierName;
    return data;
  }
}

export interface ICertificationVm {
  postId?: string | undefined;
  postTitle?: string | undefined;
  requestedAt?: Date;
  certifiedAt?: Date | undefined;
  type?: CertificationType;
  status?: CertificationStatus;
  certifierName?: string | undefined;
}

/** 0 = Audit 1 = Evaluation */
export enum CertificationType {
  Audit = 0,
  Evaluation = 1,
}

/** 0 = Pending 1 = Accepted 2 = Rejected 3 = InProgress 4 = Finished */
export enum CertificationStatus {
  Pending = 0,
  Accepted = 1,
  Rejected = 2,
  InProgress = 3,
  Finished = 4,
}

export class CertificationsPutDataCommand implements ICertificationsPutDataCommand {
  price?: number;
  isAvailable?: boolean;
  type?: CertificationType;

  constructor(data?: ICertificationsPutDataCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.price = _data['price'];
      this.isAvailable = _data['isAvailable'];
      this.type = _data['type'];
    }
  }

  static fromJS(data: any): CertificationsPutDataCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CertificationsPutDataCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['price'] = this.price;
    data['isAvailable'] = this.isAvailable;
    data['type'] = this.type;
    return data;
  }
}

export interface ICertificationsPutDataCommand {
  price?: number;
  isAvailable?: boolean;
  type?: CertificationType;
}

export class CertificationsPutStatusCommand implements ICertificationsPutStatusCommand {
  postId!: string;
  status?: CertificationStatus;

  constructor(data?: ICertificationsPutStatusCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.postId = _data['postId'];
      this.status = _data['status'];
    }
  }

  static fromJS(data: any): CertificationsPutStatusCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CertificationsPutStatusCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['postId'] = this.postId;
    data['status'] = this.status;
    return data;
  }
}

export interface ICertificationsPutStatusCommand {
  postId: string;
  status?: CertificationStatus;
}

export class ChatVm implements IChatVm {
  chatId?: number;
  receiver?: ReceiverVm | undefined;

  constructor(data?: IChatVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.chatId = _data['chatId'];
      this.receiver = _data['receiver']
        ? ReceiverVm.fromJS(_data['receiver'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): ChatVm {
    data = typeof data === 'object' ? data : {};
    let result = new ChatVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['chatId'] = this.chatId;
    data['receiver'] = this.receiver ? this.receiver.toJSON() : <any>undefined;
    return data;
  }
}

export interface IChatVm {
  chatId?: number;
  receiver?: ReceiverVm | undefined;
}

export class ReceiverVm implements IReceiverVm {
  username?: string | undefined;
  fullName?: string | undefined;
  picture?: string | undefined;

  constructor(data?: IReceiverVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.username = _data['username'];
      this.fullName = _data['fullName'];
      this.picture = _data['picture'];
    }
  }

  static fromJS(data: any): ReceiverVm {
    data = typeof data === 'object' ? data : {};
    let result = new ReceiverVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['username'] = this.username;
    data['fullName'] = this.fullName;
    data['picture'] = this.picture;
    return data;
  }
}

export interface IReceiverVm {
  username?: string | undefined;
  fullName?: string | undefined;
  picture?: string | undefined;
}

export class PaginatedListOfMessageVm implements IPaginatedListOfMessageVm {
  pageInfo?: PageInfo | undefined;
  items?: MessageVm[] | undefined;

  constructor(data?: IPaginatedListOfMessageVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(MessageVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfMessageVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfMessageVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfMessageVm {
  pageInfo?: PageInfo | undefined;
  items?: MessageVm[] | undefined;
}

export class MessageVm implements IMessageVm {
  id?: number;
  content?: string | undefined;
  type?: MessageType;
  createdAt?: Date;
  readAt?: Date | undefined;

  constructor(data?: IMessageVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.content = _data['content'];
      this.type = _data['type'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : <any>undefined;
      this.readAt = _data['readAt']
        ? new Date(_data['readAt'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): MessageVm {
    data = typeof data === 'object' ? data : {};
    let result = new MessageVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['content'] = this.content;
    data['type'] = this.type;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
    data['readAt'] = this.readAt ? this.readAt.toISOString() : <any>undefined;
    return data;
  }
}

export interface IMessageVm {
  id?: number;
  content?: string | undefined;
  type?: MessageType;
  createdAt?: Date;
  readAt?: Date | undefined;
}

/** 0 = Text 1 = Picture 2 = Voice 3 = Audio 4 = File */
export enum MessageType {
  Text = 0,
  Picture = 1,
  Voice = 2,
  Audio = 3,
  File = 4,
}

export class PaginatedListOfCityDto implements IPaginatedListOfCityDto {
  pageInfo?: PageInfo | undefined;
  items?: CityDto[] | undefined;

  constructor(data?: IPaginatedListOfCityDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(CityDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfCityDto {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfCityDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfCityDto {
  pageInfo?: PageInfo | undefined;
  items?: CityDto[] | undefined;
}

export class CityDto implements ICityDto {
  id?: number;
  name?: LocalizedStringDto | undefined;
  regions?: number;

  constructor(data?: ICityDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.regions = _data['regions'];
    }
  }

  static fromJS(data: any): CityDto {
    data = typeof data === 'object' ? data : {};
    let result = new CityDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['regions'] = this.regions;
    return data;
  }
}

export interface ICityDto {
  id?: number;
  name?: LocalizedStringDto | undefined;
  regions?: number;
}

export class CityDashboardVm implements ICityDashboardVm {
  id?: number;
  name?: string | undefined;

  constructor(data?: ICityDashboardVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
    }
  }

  static fromJS(data: any): CityDashboardVm {
    data = typeof data === 'object' ? data : {};
    let result = new CityDashboardVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    return data;
  }
}

export interface ICityDashboardVm {
  id?: number;
  name?: string | undefined;
}

export class CitiesPostPutCommon implements ICitiesPostPutCommon {
  name?: LocalizedStringDto | undefined;

  constructor(data?: ICitiesPostPutCommon) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): CitiesPostPutCommon {
    data = typeof data === 'object' ? data : {};
    let result = new CitiesPostPutCommon();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICitiesPostPutCommon {
  name?: LocalizedStringDto | undefined;
}

export class CitiesPostCommand extends CitiesPostPutCommon implements ICitiesPostCommand {
  constructor(data?: ICitiesPostCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
  }

  static fromJS(data: any): CitiesPostCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CitiesPostCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface ICitiesPostCommand extends ICitiesPostPutCommon {}

export class CitiesPutCommand extends CitiesPostPutCommon implements ICitiesPutCommand {
  id?: number;

  constructor(data?: ICitiesPutCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CitiesPutCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CitiesPutCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    super.toJSON(data);
    return data;
  }
}

export interface ICitiesPutCommand extends ICitiesPostPutCommon {
  id?: number;
}

export class CloseReasonVm implements ICloseReasonVm {
  id?: number;
  name?: string | undefined;

  constructor(data?: ICloseReasonVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
    }
  }

  static fromJS(data: any): CloseReasonVm {
    data = typeof data === 'object' ? data : {};
    let result = new CloseReasonVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    return data;
  }
}

export interface ICloseReasonVm {
  id?: number;
  name?: string | undefined;
}

export class PaginatedListOfCloseReasonDto implements IPaginatedListOfCloseReasonDto {
  pageInfo?: PageInfo | undefined;
  items?: CloseReasonDto[] | undefined;

  constructor(data?: IPaginatedListOfCloseReasonDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(CloseReasonDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfCloseReasonDto {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfCloseReasonDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfCloseReasonDto {
  pageInfo?: PageInfo | undefined;
  items?: CloseReasonDto[] | undefined;
}

export class CloseReasonDto implements ICloseReasonDto {
  id?: number;
  name?: LocalizedStringDto | undefined;

  constructor(data?: ICloseReasonDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): CloseReasonDto {
    data = typeof data === 'object' ? data : {};
    let result = new CloseReasonDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICloseReasonDto {
  id?: number;
  name?: LocalizedStringDto | undefined;
}

export class CloseReasonsPostPutCommon implements ICloseReasonsPostPutCommon {
  name?: LocalizedStringDto | undefined;

  constructor(data?: ICloseReasonsPostPutCommon) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): CloseReasonsPostPutCommon {
    data = typeof data === 'object' ? data : {};
    let result = new CloseReasonsPostPutCommon();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICloseReasonsPostPutCommon {
  name?: LocalizedStringDto | undefined;
}

export class CloseReasonsPostCommand
  extends CloseReasonsPostPutCommon
  implements ICloseReasonsPostCommand {
  constructor(data?: ICloseReasonsPostCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
  }

  static fromJS(data: any): CloseReasonsPostCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CloseReasonsPostCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface ICloseReasonsPostCommand extends ICloseReasonsPostPutCommon {}

export class CloseReasonsPutCommand
  extends CloseReasonsPostPutCommon
  implements ICloseReasonsPutCommand {
  id?: number;

  constructor(data?: ICloseReasonsPutCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CloseReasonsPutCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CloseReasonsPutCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    super.toJSON(data);
    return data;
  }
}

export interface ICloseReasonsPutCommand extends ICloseReasonsPostPutCommon {
  id?: number;
}

export class CommonQuestionVm implements ICommonQuestionVm {
  title?: string | undefined;
  answer?: string | undefined;

  constructor(data?: ICommonQuestionVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data['title'];
      this.answer = _data['answer'];
    }
  }

  static fromJS(data: any): CommonQuestionVm {
    data = typeof data === 'object' ? data : {};
    let result = new CommonQuestionVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['title'] = this.title;
    data['answer'] = this.answer;
    return data;
  }
}

export interface ICommonQuestionVm {
  title?: string | undefined;
  answer?: string | undefined;
}

export class CommonQuestionDto implements ICommonQuestionDto {
  id?: number;
  title?: LocalizedStringDto | undefined;
  answer?: LocalizedStringDto | undefined;
  order?: number;

  constructor(data?: ICommonQuestionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.title = _data['title']
        ? LocalizedStringDto.fromJS(_data['title'])
        : <any>undefined;
      this.answer = _data['answer']
        ? LocalizedStringDto.fromJS(_data['answer'])
        : <any>undefined;
      this.order = _data['order'];
    }
  }

  static fromJS(data: any): CommonQuestionDto {
    data = typeof data === 'object' ? data : {};
    let result = new CommonQuestionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['title'] = this.title ? this.title.toJSON() : <any>undefined;
    data['answer'] = this.answer ? this.answer.toJSON() : <any>undefined;
    data['order'] = this.order;
    return data;
  }
}

export interface ICommonQuestionDto {
  id?: number;
  title?: LocalizedStringDto | undefined;
  answer?: LocalizedStringDto | undefined;
  order?: number;
}

export class CommonQuestionsPostPutCommon implements ICommonQuestionsPostPutCommon {
  title?: LocalizedStringDto | undefined;
  answer?: LocalizedStringDto | undefined;

  constructor(data?: ICommonQuestionsPostPutCommon) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data['title']
        ? LocalizedStringDto.fromJS(_data['title'])
        : <any>undefined;
      this.answer = _data['answer']
        ? LocalizedStringDto.fromJS(_data['answer'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): CommonQuestionsPostPutCommon {
    data = typeof data === 'object' ? data : {};
    let result = new CommonQuestionsPostPutCommon();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['title'] = this.title ? this.title.toJSON() : <any>undefined;
    data['answer'] = this.answer ? this.answer.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICommonQuestionsPostPutCommon {
  title?: LocalizedStringDto | undefined;
  answer?: LocalizedStringDto | undefined;
}

export class CommonQuestionsPostCommand
  extends CommonQuestionsPostPutCommon
  implements ICommonQuestionsPostCommand {
  constructor(data?: ICommonQuestionsPostCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
  }

  static fromJS(data: any): CommonQuestionsPostCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CommonQuestionsPostCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface ICommonQuestionsPostCommand extends ICommonQuestionsPostPutCommon {}

export class CommonQuestionsPutCommand
  extends CommonQuestionsPostPutCommon
  implements ICommonQuestionsPutCommand {
  id?: number;

  constructor(data?: ICommonQuestionsPutCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): CommonQuestionsPutCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CommonQuestionsPutCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    super.toJSON(data);
    return data;
  }
}

export interface ICommonQuestionsPutCommand extends ICommonQuestionsPostPutCommon {
  id?: number;
}

export class CommonQuestionsPutOrderCommand implements ICommonQuestionsPutOrderCommand {
  id?: number;
  order?: number;

  constructor(data?: ICommonQuestionsPutOrderCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.order = _data['order'];
    }
  }

  static fromJS(data: any): CommonQuestionsPutOrderCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CommonQuestionsPutOrderCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['order'] = this.order;
    return data;
  }
}

export interface ICommonQuestionsPutOrderCommand {
  id?: number;
  order?: number;
}

export class DataFieldDependantVm implements IDataFieldDependantVm {
  id?: number;
  name?: string | undefined;

  constructor(data?: IDataFieldDependantVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
    }
  }

  static fromJS(data: any): DataFieldDependantVm {
    data = typeof data === 'object' ? data : {};
    let result = new DataFieldDependantVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    return data;
  }
}

export interface IDataFieldDependantVm {
  id?: number;
  name?: string | undefined;
}

export class DataFieldDto implements IDataFieldDto {
  id?: number;
  name?: LocalizedStringDto | undefined;
  precedence?: Precedence;
  type?: DataType;
  isRequired?: boolean;
  dependant?: boolean;
  categories?: number[] | undefined;
  values?: DataValueDto[] | undefined;

  constructor(data?: IDataFieldDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.precedence = _data['precedence'];
      this.type = _data['type'];
      this.isRequired = _data['isRequired'];
      this.dependant = _data['dependant'];
      if (Array.isArray(_data['categories'])) {
        this.categories = [] as any;
        for (let item of _data['categories']) this.categories!.push(item);
      }
      if (Array.isArray(_data['values'])) {
        this.values = [] as any;
        for (let item of _data['values']) this.values!.push(DataValueDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): DataFieldDto {
    data = typeof data === 'object' ? data : {};
    let result = new DataFieldDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['precedence'] = this.precedence;
    data['type'] = this.type;
    data['isRequired'] = this.isRequired;
    data['dependant'] = this.dependant;
    if (Array.isArray(this.categories)) {
      data['categories'] = [];
      for (let item of this.categories) data['categories'].push(item);
    }
    if (Array.isArray(this.values)) {
      data['values'] = [];
      for (let item of this.values) data['values'].push(item.toJSON());
    }
    return data;
  }
}

export interface IDataFieldDto {
  id?: number;
  name?: LocalizedStringDto | undefined;
  precedence?: Precedence;
  type?: DataType;
  isRequired?: boolean;
  dependant?: boolean;
  categories?: number[] | undefined;
  values?: DataValueDto[] | undefined;
}

/** 0 = Primary 1 = Secondary 2 = Last */
export enum Precedence {
  Primary = 0,
  Secondary = 1,
  Last = 2,
}

/** 0 = DateTime 1 = Date 2 = Time 3 = PhoneNumber 4 = Text 5 = MultilineText 6 = Number 7 = EmailAddress 8 = Url 9 = Boolean 10 = Checkbox 11 = RadioButton 12 = Dropdown */
export enum DataType {
  DateTime = 0,
  Date = 1,
  Time = 2,
  PhoneNumber = 3,
  Text = 4,
  MultilineText = 5,
  Number = 6,
  EmailAddress = 7,
  Url = 8,
  Boolean = 9,
  Checkbox = 10,
  RadioButton = 11,
  Dropdown = 12,
}

export class DataValueDto implements IDataValueDto {
  id?: number;
  name?: LocalizedStringDto | undefined;
  dependantDataFields?: number[] | undefined;

  constructor(data?: IDataValueDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      if (Array.isArray(_data['dependantDataFields'])) {
        this.dependantDataFields = [] as any;
        for (let item of _data['dependantDataFields'])
          this.dependantDataFields!.push(item);
      }
    }
  }

  static fromJS(data: any): DataValueDto {
    data = typeof data === 'object' ? data : {};
    let result = new DataValueDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    if (Array.isArray(this.dependantDataFields)) {
      data['dependantDataFields'] = [];
      for (let item of this.dependantDataFields) data['dependantDataFields'].push(item);
    }
    return data;
  }
}

export interface IDataValueDto {
  id?: number;
  name?: LocalizedStringDto | undefined;
  dependantDataFields?: number[] | undefined;
}

export class PaginatedListOfDataFieldDashboardVm
  implements IPaginatedListOfDataFieldDashboardVm {
  pageInfo?: PageInfo | undefined;
  items?: DataFieldDashboardVm[] | undefined;

  constructor(data?: IPaginatedListOfDataFieldDashboardVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items'])
          this.items!.push(DataFieldDashboardVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfDataFieldDashboardVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfDataFieldDashboardVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfDataFieldDashboardVm {
  pageInfo?: PageInfo | undefined;
  items?: DataFieldDashboardVm[] | undefined;
}

export class DataFieldDashboardVm implements IDataFieldDashboardVm {
  id?: number;
  name?: string | undefined;
  type?: DataType;
  isRequired?: boolean;
  dependant?: boolean;
  numberOfUsages?: number;

  constructor(data?: IDataFieldDashboardVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.type = _data['type'];
      this.isRequired = _data['isRequired'];
      this.dependant = _data['dependant'];
      this.numberOfUsages = _data['numberOfUsages'];
    }
  }

  static fromJS(data: any): DataFieldDashboardVm {
    data = typeof data === 'object' ? data : {};
    let result = new DataFieldDashboardVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['type'] = this.type;
    data['isRequired'] = this.isRequired;
    data['dependant'] = this.dependant;
    data['numberOfUsages'] = this.numberOfUsages;
    return data;
  }
}

export interface IDataFieldDashboardVm {
  id?: number;
  name?: string | undefined;
  type?: DataType;
  isRequired?: boolean;
  dependant?: boolean;
  numberOfUsages?: number;
}

export class DataFieldsPostPutCommon implements IDataFieldsPostPutCommon {
  name?: LocalizedStringDto | undefined;
  precedence?: Precedence;
  type?: DataType;
  isRequired?: boolean;
  dependant?: boolean;
  filterable?: boolean;
  categories?: number[] | undefined;
  values?: DataValueDto[] | undefined;

  constructor(data?: IDataFieldsPostPutCommon) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.precedence = _data['precedence'];
      this.type = _data['type'];
      this.isRequired = _data['isRequired'];
      this.dependant = _data['dependant'];
      this.filterable = _data['filterable'];
      if (Array.isArray(_data['categories'])) {
        this.categories = [] as any;
        for (let item of _data['categories']) this.categories!.push(item);
      }
      if (Array.isArray(_data['values'])) {
        this.values = [] as any;
        for (let item of _data['values']) this.values!.push(DataValueDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): DataFieldsPostPutCommon {
    data = typeof data === 'object' ? data : {};
    let result = new DataFieldsPostPutCommon();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['precedence'] = this.precedence;
    data['type'] = this.type;
    data['isRequired'] = this.isRequired;
    data['dependant'] = this.dependant;
    data['filterable'] = this.filterable;
    if (Array.isArray(this.categories)) {
      data['categories'] = [];
      for (let item of this.categories) data['categories'].push(item);
    }
    if (Array.isArray(this.values)) {
      data['values'] = [];
      for (let item of this.values) data['values'].push(item.toJSON());
    }
    return data;
  }
}

export interface IDataFieldsPostPutCommon {
  name?: LocalizedStringDto | undefined;
  precedence?: Precedence;
  type?: DataType;
  isRequired?: boolean;
  dependant?: boolean;
  filterable?: boolean;
  categories?: number[] | undefined;
  values?: DataValueDto[] | undefined;
}

export class DataFieldsPostCommand
  extends DataFieldsPostPutCommon
  implements IDataFieldsPostCommand {
  constructor(data?: IDataFieldsPostCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
  }

  static fromJS(data: any): DataFieldsPostCommand {
    data = typeof data === 'object' ? data : {};
    let result = new DataFieldsPostCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface IDataFieldsPostCommand extends IDataFieldsPostPutCommon {}

export class DataFieldsPutCommand
  extends DataFieldsPostPutCommon
  implements IDataFieldsPutCommand {
  id?: number;
  deleteDependantData?: boolean;

  constructor(data?: IDataFieldsPutCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.id = _data['id'];
      this.deleteDependantData = _data['deleteDependantData'];
    }
  }

  static fromJS(data: any): DataFieldsPutCommand {
    data = typeof data === 'object' ? data : {};
    let result = new DataFieldsPutCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['deleteDependantData'] = this.deleteDependantData;
    super.toJSON(data);
    return data;
  }
}

export interface IDataFieldsPutCommand extends IDataFieldsPostPutCommon {
  id?: number;
  deleteDependantData?: boolean;
}

export class PaginatedListOfPostVm implements IPaginatedListOfPostVm {
  pageInfo?: PageInfo | undefined;
  items?: PostVm[] | undefined;

  constructor(data?: IPaginatedListOfPostVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(PostVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfPostVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfPostVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfPostVm {
  pageInfo?: PageInfo | undefined;
  items?: PostVm[] | undefined;
}

export class PostVm implements IPostVm {
  permaKey?: string | undefined;
  title?: string | undefined;
  imageUrl?: string | undefined;
  city?: string | undefined;
  region?: string | undefined;
  parentSubRegion?: string | undefined;
  subRegion?: string | undefined;
  longitude?: number;
  latitude?: number;
  price?: number;
  isNegotiable?: boolean;
  favorite?: boolean;
  size?: number;
  certificationType?: CertificationType | undefined;

  constructor(data?: IPostVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.permaKey = _data['permaKey'];
      this.title = _data['title'];
      this.imageUrl = _data['imageUrl'];
      this.city = _data['city'];
      this.region = _data['region'];
      this.parentSubRegion = _data['parentSubRegion'];
      this.subRegion = _data['subRegion'];
      this.longitude = _data['longitude'];
      this.latitude = _data['latitude'];
      this.price = _data['price'];
      this.isNegotiable = _data['isNegotiable'];
      this.favorite = _data['favorite'];
      this.size = _data['size'];
      this.certificationType = _data['certificationType'];
    }
  }

  static fromJS(data: any): PostVm {
    data = typeof data === 'object' ? data : {};
    let result = new PostVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['permaKey'] = this.permaKey;
    data['title'] = this.title;
    data['imageUrl'] = this.imageUrl;
    data['city'] = this.city;
    data['region'] = this.region;
    data['parentSubRegion'] = this.parentSubRegion;
    data['subRegion'] = this.subRegion;
    data['longitude'] = this.longitude;
    data['latitude'] = this.latitude;
    data['price'] = this.price;
    data['isNegotiable'] = this.isNegotiable;
    data['favorite'] = this.favorite;
    data['size'] = this.size;
    data['certificationType'] = this.certificationType;
    return data;
  }
}

export interface IPostVm {
  permaKey?: string | undefined;
  title?: string | undefined;
  imageUrl?: string | undefined;
  city?: string | undefined;
  region?: string | undefined;
  parentSubRegion?: string | undefined;
  subRegion?: string | undefined;
  longitude?: number;
  latitude?: number;
  price?: number;
  isNegotiable?: boolean;
  favorite?: boolean;
  size?: number;
  certificationType?: CertificationType | undefined;
}

export class GroupingOfLinkVm implements IGroupingOfLinkVm {
  key?: number;
  items?: LinkVm[] | undefined;

  constructor(data?: IGroupingOfLinkVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.key = _data['key'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(LinkVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GroupingOfLinkVm {
    data = typeof data === 'object' ? data : {};
    let result = new GroupingOfLinkVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['key'] = this.key;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IGroupingOfLinkVm {
  key?: number;
  items?: LinkVm[] | undefined;
}

export class LinkVm implements ILinkVm {
  name?: string | undefined;
  url?: string | undefined;

  constructor(data?: ILinkVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.url = _data['url'];
    }
  }

  static fromJS(data: any): LinkVm {
    data = typeof data === 'object' ? data : {};
    let result = new LinkVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['url'] = this.url;
    return data;
  }
}

export interface ILinkVm {
  name?: string | undefined;
  url?: string | undefined;
}

export class PaginatedListOfLinkDto implements IPaginatedListOfLinkDto {
  pageInfo?: PageInfo | undefined;
  items?: LinkDto[] | undefined;

  constructor(data?: IPaginatedListOfLinkDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(LinkDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfLinkDto {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfLinkDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfLinkDto {
  pageInfo?: PageInfo | undefined;
  items?: LinkDto[] | undefined;
}

export class LinkDto implements ILinkDto {
  id?: number;
  name?: LocalizedStringDto | undefined;
  type?: LinkType;
  url?: string | undefined;

  constructor(data?: ILinkDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.type = _data['type'];
      this.url = _data['url'];
    }
  }

  static fromJS(data: any): LinkDto {
    data = typeof data === 'object' ? data : {};
    let result = new LinkDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['type'] = this.type;
    data['url'] = this.url;
    return data;
  }
}

export interface ILinkDto {
  id?: number;
  name?: LocalizedStringDto | undefined;
  type?: LinkType;
  url?: string | undefined;
}

/** 0 = MostSelling 1 = MostViewed */
export enum LinkType {
  MostSelling = 0,
  MostViewed = 1,
}

export class LinksPostPutCommon implements ILinksPostPutCommon {
  name?: LocalizedStringDto | undefined;
  type?: LinkType;
  url?: string | undefined;

  constructor(data?: ILinksPostPutCommon) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.type = _data['type'];
      this.url = _data['url'];
    }
  }

  static fromJS(data: any): LinksPostPutCommon {
    data = typeof data === 'object' ? data : {};
    let result = new LinksPostPutCommon();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['type'] = this.type;
    data['url'] = this.url;
    return data;
  }
}

export interface ILinksPostPutCommon {
  name?: LocalizedStringDto | undefined;
  type?: LinkType;
  url?: string | undefined;
}

export class LinksPostCommand extends LinksPostPutCommon implements ILinksPostCommand {
  constructor(data?: ILinksPostCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
  }

  static fromJS(data: any): LinksPostCommand {
    data = typeof data === 'object' ? data : {};
    let result = new LinksPostCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface ILinksPostCommand extends ILinksPostPutCommon {}

export class LinksPutCommand extends LinksPostPutCommon implements ILinksPutCommand {
  id?: number;

  constructor(data?: ILinksPutCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): LinksPutCommand {
    data = typeof data === 'object' ? data : {};
    let result = new LinksPutCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    super.toJSON(data);
    return data;
  }
}

export interface ILinksPutCommand extends ILinksPostPutCommon {
  id?: number;
}

export class PaginatedListOfNotificationVm implements IPaginatedListOfNotificationVm {
  pageInfo?: PageInfo | undefined;
  items?: NotificationVm[] | undefined;

  constructor(data?: IPaginatedListOfNotificationVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(NotificationVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfNotificationVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfNotificationVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfNotificationVm {
  pageInfo?: PageInfo | undefined;
  items?: NotificationVm[] | undefined;
}

export class NotificationVm implements INotificationVm {
  id?: number;
  type?: NotificationType;
  createdAt?: Date;
  isRead?: boolean;
  details?: string | undefined;

  constructor(data?: INotificationVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.type = _data['type'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : <any>undefined;
      this.isRead = _data['isRead'];
      this.details = _data['details'];
    }
  }

  static fromJS(data: any): NotificationVm {
    data = typeof data === 'object' ? data : {};
    let result = new NotificationVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['type'] = this.type;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
    data['isRead'] = this.isRead;
    data['details'] = this.details;
    return data;
  }
}

export interface INotificationVm {
  id?: number;
  type?: NotificationType;
  createdAt?: Date;
  isRead?: boolean;
  details?: string | undefined;
}

/** 0 = PostAdded 1 = PostUpdated 2 = CertificationRequest */
export enum NotificationType {
  PostAdded = 0,
  PostUpdated = 1,
  CertificationRequest = 2,
}

export class PaginatedListOfPlaceDashboardVm implements IPaginatedListOfPlaceDashboardVm {
  pageInfo?: PageInfo | undefined;
  items?: PlaceDashboardVm[] | undefined;

  constructor(data?: IPaginatedListOfPlaceDashboardVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(PlaceDashboardVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfPlaceDashboardVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfPlaceDashboardVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfPlaceDashboardVm {
  pageInfo?: PageInfo | undefined;
  items?: PlaceDashboardVm[] | undefined;
}

export class PlaceDashboardVm implements IPlaceDashboardVm {
  id?: number;
  name?: string | undefined;
  type?: PlaceType;

  constructor(data?: IPlaceDashboardVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.type = _data['type'];
    }
  }

  static fromJS(data: any): PlaceDashboardVm {
    data = typeof data === 'object' ? data : {};
    let result = new PlaceDashboardVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['type'] = this.type;
    return data;
  }
}

export interface IPlaceDashboardVm {
  id?: number;
  name?: string | undefined;
  type?: PlaceType;
}

/** 0 = Historical 1 = Governmental 2 = Educational 3 = Entertaining 4 = Social 5 = Local 6 = Building */
export enum PlaceType {
  Historical = 0,
  Governmental = 1,
  Educational = 2,
  Entertaining = 3,
  Social = 4,
  Local = 5,
  Building = 6,
}

export class PlacesPostPutCommon implements IPlacesPostPutCommon {
  name?: LocalizedStringDto | undefined;
  location?: LocationDto | undefined;
  type?: PlaceType;

  constructor(data?: IPlacesPostPutCommon) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.location = _data['location']
        ? LocationDto.fromJS(_data['location'])
        : <any>undefined;
      this.type = _data['type'];
    }
  }

  static fromJS(data: any): PlacesPostPutCommon {
    data = typeof data === 'object' ? data : {};
    let result = new PlacesPostPutCommon();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['location'] = this.location ? this.location.toJSON() : <any>undefined;
    data['type'] = this.type;
    return data;
  }
}

export interface IPlacesPostPutCommon {
  name?: LocalizedStringDto | undefined;
  location?: LocationDto | undefined;
  type?: PlaceType;
}

export class PlacesPostCommand extends PlacesPostPutCommon implements IPlacesPostCommand {
  constructor(data?: IPlacesPostCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
  }

  static fromJS(data: any): PlacesPostCommand {
    data = typeof data === 'object' ? data : {};
    let result = new PlacesPostCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface IPlacesPostCommand extends IPlacesPostPutCommon {}

export class LocationDto implements ILocationDto {
  cityId?: number;
  regionId?: number;
  parentSubRegionId?: number | undefined;
  subRegionId?: number | undefined;
  longitude?: number;
  latitude?: number;

  constructor(data?: ILocationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.cityId = _data['cityId'];
      this.regionId = _data['regionId'];
      this.parentSubRegionId = _data['parentSubRegionId'];
      this.subRegionId = _data['subRegionId'];
      this.longitude = _data['longitude'];
      this.latitude = _data['latitude'];
    }
  }

  static fromJS(data: any): LocationDto {
    data = typeof data === 'object' ? data : {};
    let result = new LocationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['cityId'] = this.cityId;
    data['regionId'] = this.regionId;
    data['parentSubRegionId'] = this.parentSubRegionId;
    data['subRegionId'] = this.subRegionId;
    data['longitude'] = this.longitude;
    data['latitude'] = this.latitude;
    return data;
  }
}

export interface ILocationDto {
  cityId?: number;
  regionId?: number;
  parentSubRegionId?: number | undefined;
  subRegionId?: number | undefined;
  longitude?: number;
  latitude?: number;
}

export class PlacesPutCommand extends PlacesPostPutCommon implements IPlacesPutCommand {
  id?: number;

  constructor(data?: IPlacesPutCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): PlacesPutCommand {
    data = typeof data === 'object' ? data : {};
    let result = new PlacesPutCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    super.toJSON(data);
    return data;
  }
}

export interface IPlacesPutCommand extends IPlacesPostPutCommon {
  id?: number;
}

export class PostFilterDto implements IPostFilterDto {
  id?: number;
  name?: string | undefined;
  type?: FilterType;
  value?: string | undefined;
  minValue?: number;
  maxValue?: number;
  checked?: boolean;
  values?: DataValueVm[] | undefined;

  constructor(data?: IPostFilterDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.type = _data['type'];
      this.value = _data['value'];
      this.minValue = _data['minValue'];
      this.maxValue = _data['maxValue'];
      this.checked = _data['checked'];
      if (Array.isArray(_data['values'])) {
        this.values = [] as any;
        for (let item of _data['values']) this.values!.push(DataValueVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PostFilterDto {
    data = typeof data === 'object' ? data : {};
    let result = new PostFilterDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['type'] = this.type;
    data['value'] = this.value;
    data['minValue'] = this.minValue;
    data['maxValue'] = this.maxValue;
    data['checked'] = this.checked;
    if (Array.isArray(this.values)) {
      data['values'] = [];
      for (let item of this.values) data['values'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPostFilterDto {
  id?: number;
  name?: string | undefined;
  type?: FilterType;
  value?: string | undefined;
  minValue?: number;
  maxValue?: number;
  checked?: boolean;
  values?: DataValueVm[] | undefined;
}

/** 0 = Text 1 = Range 2 = Dropdown 3 = MultiDropdown 4 = Checkbox */
export enum FilterType {
  Text = 0,
  Range = 1,
  Dropdown = 2,
  MultiDropdown = 3,
  Checkbox = 4,
}

export class DataValueVm implements IDataValueVm {
  id?: number;
  name?: string | undefined;
  selected?: boolean;

  constructor(data?: IDataValueVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.selected = _data['selected'];
    }
  }

  static fromJS(data: any): DataValueVm {
    data = typeof data === 'object' ? data : {};
    let result = new DataValueVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['selected'] = this.selected;
    return data;
  }
}

export interface IDataValueVm {
  id?: number;
  name?: string | undefined;
  selected?: boolean;
}

export class PostGroups implements IPostGroups {
  claro?: PostVm[] | undefined;
  residential?: PostVm[] | undefined;
  unResidential?: PostVm[] | undefined;

  constructor(data?: IPostGroups) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['claro'])) {
        this.claro = [] as any;
        for (let item of _data['claro']) this.claro!.push(PostVm.fromJS(item));
      }
      if (Array.isArray(_data['residential'])) {
        this.residential = [] as any;
        for (let item of _data['residential'])
          this.residential!.push(PostVm.fromJS(item));
      }
      if (Array.isArray(_data['unResidential'])) {
        this.unResidential = [] as any;
        for (let item of _data['unResidential'])
          this.unResidential!.push(PostVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PostGroups {
    data = typeof data === 'object' ? data : {};
    let result = new PostGroups();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.claro)) {
      data['claro'] = [];
      for (let item of this.claro) data['claro'].push(item.toJSON());
    }
    if (Array.isArray(this.residential)) {
      data['residential'] = [];
      for (let item of this.residential) data['residential'].push(item.toJSON());
    }
    if (Array.isArray(this.unResidential)) {
      data['unResidential'] = [];
      for (let item of this.unResidential) data['unResidential'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPostGroups {
  claro?: PostVm[] | undefined;
  residential?: PostVm[] | undefined;
  unResidential?: PostVm[] | undefined;
}

export class PaginatedListOfPostDashboardVm implements IPaginatedListOfPostDashboardVm {
  pageInfo?: PageInfo | undefined;
  items?: PostDashboardVm[] | undefined;

  constructor(data?: IPaginatedListOfPostDashboardVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(PostDashboardVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfPostDashboardVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfPostDashboardVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfPostDashboardVm {
  pageInfo?: PageInfo | undefined;
  items?: PostDashboardVm[] | undefined;
}

export class PostDashboardVm implements IPostDashboardVm {
  id?: string | undefined;
  permaKey?: string | undefined;
  title?: string | undefined;
  size?: number;
  createdAt?: Date;
  status?: PostStatus;
  ownerRelation?: OwnerRelation;

  constructor(data?: IPostDashboardVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.permaKey = _data['permaKey'];
      this.title = _data['title'];
      this.size = _data['size'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : <any>undefined;
      this.status = _data['status'];
      this.ownerRelation = _data['ownerRelation'];
    }
  }

  static fromJS(data: any): PostDashboardVm {
    data = typeof data === 'object' ? data : {};
    let result = new PostDashboardVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['permaKey'] = this.permaKey;
    data['title'] = this.title;
    data['size'] = this.size;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
    data['status'] = this.status;
    data['ownerRelation'] = this.ownerRelation;
    return data;
  }
}

export interface IPostDashboardVm {
  id?: string | undefined;
  permaKey?: string | undefined;
  title?: string | undefined;
  size?: number;
  createdAt?: Date;
  status?: PostStatus;
  ownerRelation?: OwnerRelation;
}

/** 0 = Pending 1 = Accepted 2 = Rejected 3 = Closed */
export enum PostStatus {
  Pending = 0,
  Accepted = 1,
  Rejected = 2,
  Closed = 3,
}

/** 0 = Relative 1 = Representative 2 = SellingAgent */
export enum OwnerRelation {
  Relative = 0,
  Representative = 1,
  SellingAgent = 2,
}

export class PostDetailsVm implements IPostDetailsVm {
  title?: string | undefined;
  location?: LocationVm | undefined;
  sellingDetails?: SellingDetailsVm | undefined;
  rentingDetails?: RentingDetailsVm | undefined;
  certificationType?: CertificationType | undefined;
  price?: number;
  size?: number;
  netSize?: number | undefined;
  createdAt?: Date;
  userFullName?: string | undefined;
  username?: string | undefined;
  numberOfViews?: number;
  attachments?: AttachmentDto[] | undefined;
  entries?: EntryVm[] | undefined;
  views?: ViewVm[] | undefined;

  constructor(data?: IPostDetailsVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data['title'];
      this.location = _data['location']
        ? LocationVm.fromJS(_data['location'])
        : <any>undefined;
      this.sellingDetails = _data['sellingDetails']
        ? SellingDetailsVm.fromJS(_data['sellingDetails'])
        : <any>undefined;
      this.rentingDetails = _data['rentingDetails']
        ? RentingDetailsVm.fromJS(_data['rentingDetails'])
        : <any>undefined;
      this.certificationType = _data['certificationType'];
      this.price = _data['price'];
      this.size = _data['size'];
      this.netSize = _data['netSize'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : <any>undefined;
      this.userFullName = _data['userFullName'];
      this.username = _data['username'];
      this.numberOfViews = _data['numberOfViews'];
      if (Array.isArray(_data['attachments'])) {
        this.attachments = [] as any;
        for (let item of _data['attachments'])
          this.attachments!.push(AttachmentDto.fromJS(item));
      }
      if (Array.isArray(_data['entries'])) {
        this.entries = [] as any;
        for (let item of _data['entries']) this.entries!.push(EntryVm.fromJS(item));
      }
      if (Array.isArray(_data['views'])) {
        this.views = [] as any;
        for (let item of _data['views']) this.views!.push(ViewVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PostDetailsVm {
    data = typeof data === 'object' ? data : {};
    let result = new PostDetailsVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['title'] = this.title;
    data['location'] = this.location ? this.location.toJSON() : <any>undefined;
    data['sellingDetails'] = this.sellingDetails
      ? this.sellingDetails.toJSON()
      : <any>undefined;
    data['rentingDetails'] = this.rentingDetails
      ? this.rentingDetails.toJSON()
      : <any>undefined;
    data['certificationType'] = this.certificationType;
    data['price'] = this.price;
    data['size'] = this.size;
    data['netSize'] = this.netSize;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
    data['userFullName'] = this.userFullName;
    data['username'] = this.username;
    data['numberOfViews'] = this.numberOfViews;
    if (Array.isArray(this.attachments)) {
      data['attachments'] = [];
      for (let item of this.attachments) data['attachments'].push(item.toJSON());
    }
    if (Array.isArray(this.entries)) {
      data['entries'] = [];
      for (let item of this.entries) data['entries'].push(item.toJSON());
    }
    if (Array.isArray(this.views)) {
      data['views'] = [];
      for (let item of this.views) data['views'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPostDetailsVm {
  title?: string | undefined;
  location?: LocationVm | undefined;
  sellingDetails?: SellingDetailsVm | undefined;
  rentingDetails?: RentingDetailsVm | undefined;
  certificationType?: CertificationType | undefined;
  price?: number;
  size?: number;
  netSize?: number | undefined;
  createdAt?: Date;
  userFullName?: string | undefined;
  username?: string | undefined;
  numberOfViews?: number;
  attachments?: AttachmentDto[] | undefined;
  entries?: EntryVm[] | undefined;
  views?: ViewVm[] | undefined;
}

export class LocationVm implements ILocationVm {
  city?: string | undefined;
  region?: string | undefined;
  regionVideoUrl?: string | undefined;
  parentSubRegion?: string | undefined;
  subRegion?: string | undefined;
  longitude?: number;
  latitude?: number;

  constructor(data?: ILocationVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.city = _data['city'];
      this.region = _data['region'];
      this.regionVideoUrl = _data['regionVideoUrl'];
      this.parentSubRegion = _data['parentSubRegion'];
      this.subRegion = _data['subRegion'];
      this.longitude = _data['longitude'];
      this.latitude = _data['latitude'];
    }
  }

  static fromJS(data: any): LocationVm {
    data = typeof data === 'object' ? data : {};
    let result = new LocationVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['city'] = this.city;
    data['region'] = this.region;
    data['regionVideoUrl'] = this.regionVideoUrl;
    data['parentSubRegion'] = this.parentSubRegion;
    data['subRegion'] = this.subRegion;
    data['longitude'] = this.longitude;
    data['latitude'] = this.latitude;
    return data;
  }
}

export interface ILocationVm {
  city?: string | undefined;
  region?: string | undefined;
  regionVideoUrl?: string | undefined;
  parentSubRegion?: string | undefined;
  subRegion?: string | undefined;
  longitude?: number;
  latitude?: number;
}

export class SellingDetailsVm implements ISellingDetailsVm {
  paymentType?: PaymentType;
  price?: number;
  firstBatch?: number | undefined;
  remaining?: number | undefined;
  installmentYears?: number | undefined;
  isNegotiable?: boolean;
  includesMaintenanceDeposit?: boolean;

  constructor(data?: ISellingDetailsVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.paymentType = _data['paymentType'];
      this.price = _data['price'];
      this.firstBatch = _data['firstBatch'];
      this.remaining = _data['remaining'];
      this.installmentYears = _data['installmentYears'];
      this.isNegotiable = _data['isNegotiable'];
      this.includesMaintenanceDeposit = _data['includesMaintenanceDeposit'];
    }
  }

  static fromJS(data: any): SellingDetailsVm {
    data = typeof data === 'object' ? data : {};
    let result = new SellingDetailsVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['paymentType'] = this.paymentType;
    data['price'] = this.price;
    data['firstBatch'] = this.firstBatch;
    data['remaining'] = this.remaining;
    data['installmentYears'] = this.installmentYears;
    data['isNegotiable'] = this.isNegotiable;
    data['includesMaintenanceDeposit'] = this.includesMaintenanceDeposit;
    return data;
  }
}

export interface ISellingDetailsVm {
  paymentType?: PaymentType;
  price?: number;
  firstBatch?: number | undefined;
  remaining?: number | undefined;
  installmentYears?: number | undefined;
  isNegotiable?: boolean;
  includesMaintenanceDeposit?: boolean;
}

/** 0 = Cash 1 = Installment 2 = Both */
export enum PaymentType {
  Cash = 0,
  Installment = 1,
  Both = 2,
}

export class RentingDetailsVm implements IRentingDetailsVm {
  periodType?: PeriodType;
  periodRange?: number;
  price?: number;
  annualIncreaseRate?: number;
  annualIncreaseValue?: number;
  maintenanceType?: MaintenanceType;
  insuranceType?: InsuranceType;
  maintenanceValue?: number;
  insuranceValue?: number;

  constructor(data?: IRentingDetailsVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.periodType = _data['periodType'];
      this.periodRange = _data['periodRange'];
      this.price = _data['price'];
      this.annualIncreaseRate = _data['annualIncreaseRate'];
      this.annualIncreaseValue = _data['annualIncreaseValue'];
      this.maintenanceType = _data['maintenanceType'];
      this.insuranceType = _data['insuranceType'];
      this.maintenanceValue = _data['maintenanceValue'];
      this.insuranceValue = _data['insuranceValue'];
    }
  }

  static fromJS(data: any): RentingDetailsVm {
    data = typeof data === 'object' ? data : {};
    let result = new RentingDetailsVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['periodType'] = this.periodType;
    data['periodRange'] = this.periodRange;
    data['price'] = this.price;
    data['annualIncreaseRate'] = this.annualIncreaseRate;
    data['annualIncreaseValue'] = this.annualIncreaseValue;
    data['maintenanceType'] = this.maintenanceType;
    data['insuranceType'] = this.insuranceType;
    data['maintenanceValue'] = this.maintenanceValue;
    data['insuranceValue'] = this.insuranceValue;
    return data;
  }
}

export interface IRentingDetailsVm {
  periodType?: PeriodType;
  periodRange?: number;
  price?: number;
  annualIncreaseRate?: number;
  annualIncreaseValue?: number;
  maintenanceType?: MaintenanceType;
  insuranceType?: InsuranceType;
  maintenanceValue?: number;
  insuranceValue?: number;
}

/** 0 = Hourly 1 = Daily 2 = Weekly 3 = Monthly 4 = Yearly */
export enum PeriodType {
  Hourly = 0,
  Daily = 1,
  Weekly = 2,
  Monthly = 3,
  Yearly = 4,
}

/** 0 = Paid 1 = Unpaid */
export enum MaintenanceType {
  Paid = 0,
  Unpaid = 1,
}

/** 0 = Month 1 = Year */
export enum InsuranceType {
  Month = 0,
  Year = 1,
}

export class AttachmentDto implements IAttachmentDto {
  id?: number;
  type?: AttachmentType;
  file?: string | undefined;
  url?: string | undefined;

  constructor(data?: IAttachmentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.type = _data['type'];
      this.file = _data['file'];
      this.url = _data['url'];
    }
  }

  static fromJS(data: any): AttachmentDto {
    data = typeof data === 'object' ? data : {};
    let result = new AttachmentDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['type'] = this.type;
    data['file'] = this.file;
    data['url'] = this.url;
    return data;
  }
}

export interface IAttachmentDto {
  id?: number;
  type?: AttachmentType;
  file?: string | undefined;
  url?: string | undefined;
}

/** 0 = Picture 1 = Video 2 = Document */
export enum AttachmentType {
  Picture = 0,
  Video = 1,
  Document = 2,
}

export class EntryVm implements IEntryVm {
  fieldName?: string | undefined;
  values?: string[] | undefined;

  constructor(data?: IEntryVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fieldName = _data['fieldName'];
      if (Array.isArray(_data['values'])) {
        this.values = [] as any;
        for (let item of _data['values']) this.values!.push(item);
      }
    }
  }

  static fromJS(data: any): EntryVm {
    data = typeof data === 'object' ? data : {};
    let result = new EntryVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['fieldName'] = this.fieldName;
    if (Array.isArray(this.values)) {
      data['values'] = [];
      for (let item of this.values) data['values'].push(item);
    }
    return data;
  }
}

export interface IEntryVm {
  fieldName?: string | undefined;
  values?: string[] | undefined;
}

export class ViewVm implements IViewVm {
  direction?: ViewDirection;
  place?: string | undefined;

  constructor(data?: IViewVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.direction = _data['direction'];
      this.place = _data['place'];
    }
  }

  static fromJS(data: any): ViewVm {
    data = typeof data === 'object' ? data : {};
    let result = new ViewVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['direction'] = this.direction;
    data['place'] = this.place;
    return data;
  }
}

export interface IViewVm {
  direction?: ViewDirection;
  place?: string | undefined;
}

/** 0 = North 1 = South 2 = East 3 = West 4 = SameLocation 5 = SameStreet 6 = NearBy */
export enum ViewDirection {
  North = 0,
  South = 1,
  East = 2,
  West = 3,
  SameLocation = 4,
  SameStreet = 5,
  NearBy = 6,
}

export class PostDto implements IPostDto {
  location?: LocationDto | undefined;
  sellingDetails?: SellingDetailsDto | undefined;
  rentingDetails?: RentingDetailsDto | undefined;
  size?: number;
  netSize?: number | undefined;
  ownerRelation?: OwnerRelation;
  categoryId?: number;
  attachments?: AttachmentDto[] | undefined;
  categories?: CategoryFullVm[] | undefined;
  cities?: CityVm[] | undefined;
  places?: PlaceVm[] | undefined;
  certifications?: CertificationDataVm[] | undefined;

  constructor(data?: IPostDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.location = _data['location']
        ? LocationDto.fromJS(_data['location'])
        : <any>undefined;
      this.sellingDetails = _data['sellingDetails']
        ? SellingDetailsDto.fromJS(_data['sellingDetails'])
        : <any>undefined;
      this.rentingDetails = _data['rentingDetails']
        ? RentingDetailsDto.fromJS(_data['rentingDetails'])
        : <any>undefined;
      this.size = _data['size'];
      this.netSize = _data['netSize'];
      this.ownerRelation = _data['ownerRelation'];
      this.categoryId = _data['categoryId'];
      if (Array.isArray(_data['attachments'])) {
        this.attachments = [] as any;
        for (let item of _data['attachments'])
          this.attachments!.push(AttachmentDto.fromJS(item));
      }
      if (Array.isArray(_data['categories'])) {
        this.categories = [] as any;
        for (let item of _data['categories'])
          this.categories!.push(CategoryFullVm.fromJS(item));
      }
      if (Array.isArray(_data['cities'])) {
        this.cities = [] as any;
        for (let item of _data['cities']) this.cities!.push(CityVm.fromJS(item));
      }
      if (Array.isArray(_data['places'])) {
        this.places = [] as any;
        for (let item of _data['places']) this.places!.push(PlaceVm.fromJS(item));
      }
      if (Array.isArray(_data['certifications'])) {
        this.certifications = [] as any;
        for (let item of _data['certifications'])
          this.certifications!.push(CertificationDataVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PostDto {
    data = typeof data === 'object' ? data : {};
    let result = new PostDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['location'] = this.location ? this.location.toJSON() : <any>undefined;
    data['sellingDetails'] = this.sellingDetails
      ? this.sellingDetails.toJSON()
      : <any>undefined;
    data['rentingDetails'] = this.rentingDetails
      ? this.rentingDetails.toJSON()
      : <any>undefined;
    data['size'] = this.size;
    data['netSize'] = this.netSize;
    data['ownerRelation'] = this.ownerRelation;
    data['categoryId'] = this.categoryId;
    if (Array.isArray(this.attachments)) {
      data['attachments'] = [];
      for (let item of this.attachments) data['attachments'].push(item.toJSON());
    }
    if (Array.isArray(this.categories)) {
      data['categories'] = [];
      for (let item of this.categories) data['categories'].push(item.toJSON());
    }
    if (Array.isArray(this.cities)) {
      data['cities'] = [];
      for (let item of this.cities) data['cities'].push(item.toJSON());
    }
    if (Array.isArray(this.places)) {
      data['places'] = [];
      for (let item of this.places) data['places'].push(item.toJSON());
    }
    if (Array.isArray(this.certifications)) {
      data['certifications'] = [];
      for (let item of this.certifications) data['certifications'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPostDto {
  location?: LocationDto | undefined;
  sellingDetails?: SellingDetailsDto | undefined;
  rentingDetails?: RentingDetailsDto | undefined;
  size?: number;
  netSize?: number | undefined;
  ownerRelation?: OwnerRelation;
  categoryId?: number;
  attachments?: AttachmentDto[] | undefined;
  categories?: CategoryFullVm[] | undefined;
  cities?: CityVm[] | undefined;
  places?: PlaceVm[] | undefined;
  certifications?: CertificationDataVm[] | undefined;
}

export class SellingDetailsDto implements ISellingDetailsDto {
  paymentType?: PaymentType;
  price?: number;
  firstBatch?: number | undefined;
  remaining?: number | undefined;
  installmentYears?: number | undefined;
  isNegotiable?: boolean;
  includesMaintenanceDeposit?: boolean;

  constructor(data?: ISellingDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.paymentType = _data['paymentType'];
      this.price = _data['price'];
      this.firstBatch = _data['firstBatch'];
      this.remaining = _data['remaining'];
      this.installmentYears = _data['installmentYears'];
      this.isNegotiable = _data['isNegotiable'];
      this.includesMaintenanceDeposit = _data['includesMaintenanceDeposit'];
    }
  }

  static fromJS(data: any): SellingDetailsDto {
    data = typeof data === 'object' ? data : {};
    let result = new SellingDetailsDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['paymentType'] = this.paymentType;
    data['price'] = this.price;
    data['firstBatch'] = this.firstBatch;
    data['remaining'] = this.remaining;
    data['installmentYears'] = this.installmentYears;
    data['isNegotiable'] = this.isNegotiable;
    data['includesMaintenanceDeposit'] = this.includesMaintenanceDeposit;
    return data;
  }
}

export interface ISellingDetailsDto {
  paymentType?: PaymentType;
  price?: number;
  firstBatch?: number | undefined;
  remaining?: number | undefined;
  installmentYears?: number | undefined;
  isNegotiable?: boolean;
  includesMaintenanceDeposit?: boolean;
}

export class RentingDetailsDto implements IRentingDetailsDto {
  periodType?: PeriodType;
  periodRange?: number;
  price?: number;
  annualIncreaseRate?: number;
  annualIncreaseValue?: number;
  maintenanceType?: MaintenanceType;
  insuranceType?: InsuranceType;
  maintenanceValue?: number;
  insuranceValue?: number;

  constructor(data?: IRentingDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.periodType = _data['periodType'];
      this.periodRange = _data['periodRange'];
      this.price = _data['price'];
      this.annualIncreaseRate = _data['annualIncreaseRate'];
      this.annualIncreaseValue = _data['annualIncreaseValue'];
      this.maintenanceType = _data['maintenanceType'];
      this.insuranceType = _data['insuranceType'];
      this.maintenanceValue = _data['maintenanceValue'];
      this.insuranceValue = _data['insuranceValue'];
    }
  }

  static fromJS(data: any): RentingDetailsDto {
    data = typeof data === 'object' ? data : {};
    let result = new RentingDetailsDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['periodType'] = this.periodType;
    data['periodRange'] = this.periodRange;
    data['price'] = this.price;
    data['annualIncreaseRate'] = this.annualIncreaseRate;
    data['annualIncreaseValue'] = this.annualIncreaseValue;
    data['maintenanceType'] = this.maintenanceType;
    data['insuranceType'] = this.insuranceType;
    data['maintenanceValue'] = this.maintenanceValue;
    data['insuranceValue'] = this.insuranceValue;
    return data;
  }
}

export interface IRentingDetailsDto {
  periodType?: PeriodType;
  periodRange?: number;
  price?: number;
  annualIncreaseRate?: number;
  annualIncreaseValue?: number;
  maintenanceType?: MaintenanceType;
  insuranceType?: InsuranceType;
  maintenanceValue?: number;
  insuranceValue?: number;
}

export class CategoryFullVm implements ICategoryFullVm {
  id?: number;
  name?: string | undefined;
  type?: CategoryType;
  dataFields?: DataFieldVm[] | undefined;

  constructor(data?: ICategoryFullVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.type = _data['type'];
      if (Array.isArray(_data['dataFields'])) {
        this.dataFields = [] as any;
        for (let item of _data['dataFields'])
          this.dataFields!.push(DataFieldVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): CategoryFullVm {
    data = typeof data === 'object' ? data : {};
    let result = new CategoryFullVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['type'] = this.type;
    if (Array.isArray(this.dataFields)) {
      data['dataFields'] = [];
      for (let item of this.dataFields) data['dataFields'].push(item.toJSON());
    }
    return data;
  }
}

export interface ICategoryFullVm {
  id?: number;
  name?: string | undefined;
  type?: CategoryType;
  dataFields?: DataFieldVm[] | undefined;
}

export class DataFieldVm implements IDataFieldVm {
  id?: number;
  name?: string | undefined;
  precedence?: Precedence;
  type?: DataType;
  isRequired?: boolean;
  value?: string | undefined;
  values?: DataValueFullVm[] | undefined;

  constructor(data?: IDataFieldVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.precedence = _data['precedence'];
      this.type = _data['type'];
      this.isRequired = _data['isRequired'];
      this.value = _data['value'];
      if (Array.isArray(_data['values'])) {
        this.values = [] as any;
        for (let item of _data['values']) this.values!.push(DataValueFullVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): DataFieldVm {
    data = typeof data === 'object' ? data : {};
    let result = new DataFieldVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['precedence'] = this.precedence;
    data['type'] = this.type;
    data['isRequired'] = this.isRequired;
    data['value'] = this.value;
    if (Array.isArray(this.values)) {
      data['values'] = [];
      for (let item of this.values) data['values'].push(item.toJSON());
    }
    return data;
  }
}

export interface IDataFieldVm {
  id?: number;
  name?: string | undefined;
  precedence?: Precedence;
  type?: DataType;
  isRequired?: boolean;
  value?: string | undefined;
  values?: DataValueFullVm[] | undefined;
}

export class DataValueFullVm implements IDataValueFullVm {
  id?: number;
  name?: string | undefined;
  selected?: boolean;
  dependantDataFields?: DataFieldVm[] | undefined;

  constructor(data?: IDataValueFullVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.selected = _data['selected'];
      if (Array.isArray(_data['dependantDataFields'])) {
        this.dependantDataFields = [] as any;
        for (let item of _data['dependantDataFields'])
          this.dependantDataFields!.push(DataFieldVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): DataValueFullVm {
    data = typeof data === 'object' ? data : {};
    let result = new DataValueFullVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['selected'] = this.selected;
    if (Array.isArray(this.dependantDataFields)) {
      data['dependantDataFields'] = [];
      for (let item of this.dependantDataFields)
        data['dependantDataFields'].push(item.toJSON());
    }
    return data;
  }
}

export interface IDataValueFullVm {
  id?: number;
  name?: string | undefined;
  selected?: boolean;
  dependantDataFields?: DataFieldVm[] | undefined;
}

export class CityVm implements ICityVm {
  id?: number;
  name?: string | undefined;
  regions?: RegionVm[] | undefined;

  constructor(data?: ICityVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      if (Array.isArray(_data['regions'])) {
        this.regions = [] as any;
        for (let item of _data['regions']) this.regions!.push(RegionVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): CityVm {
    data = typeof data === 'object' ? data : {};
    let result = new CityVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    if (Array.isArray(this.regions)) {
      data['regions'] = [];
      for (let item of this.regions) data['regions'].push(item.toJSON());
    }
    return data;
  }
}

export interface ICityVm {
  id?: number;
  name?: string | undefined;
  regions?: RegionVm[] | undefined;
}

export class RegionVm implements IRegionVm {
  id?: number;
  name?: string | undefined;
  isSupported?: boolean;
  subRegions?: SubRegionVm[] | undefined;

  constructor(data?: IRegionVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.isSupported = _data['isSupported'];
      if (Array.isArray(_data['subRegions'])) {
        this.subRegions = [] as any;
        for (let item of _data['subRegions'])
          this.subRegions!.push(SubRegionVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): RegionVm {
    data = typeof data === 'object' ? data : {};
    let result = new RegionVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['isSupported'] = this.isSupported;
    if (Array.isArray(this.subRegions)) {
      data['subRegions'] = [];
      for (let item of this.subRegions) data['subRegions'].push(item.toJSON());
    }
    return data;
  }
}

export interface IRegionVm {
  id?: number;
  name?: string | undefined;
  isSupported?: boolean;
  subRegions?: SubRegionVm[] | undefined;
}

export class SubRegionVm implements ISubRegionVm {
  id?: number;
  name?: string | undefined;
  isSupported?: boolean;
  childSubRegions?: SubRegionVm[] | undefined;

  constructor(data?: ISubRegionVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.isSupported = _data['isSupported'];
      if (Array.isArray(_data['childSubRegions'])) {
        this.childSubRegions = [] as any;
        for (let item of _data['childSubRegions'])
          this.childSubRegions!.push(SubRegionVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): SubRegionVm {
    data = typeof data === 'object' ? data : {};
    let result = new SubRegionVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['isSupported'] = this.isSupported;
    if (Array.isArray(this.childSubRegions)) {
      data['childSubRegions'] = [];
      for (let item of this.childSubRegions) data['childSubRegions'].push(item.toJSON());
    }
    return data;
  }
}

export interface ISubRegionVm {
  id?: number;
  name?: string | undefined;
  isSupported?: boolean;
  childSubRegions?: SubRegionVm[] | undefined;
}

export class PlaceVm implements IPlaceVm {
  id?: number;
  name?: string | undefined;
  selected?: boolean;
  viewDirection?: ViewDirection;

  constructor(data?: IPlaceVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.selected = _data['selected'];
      this.viewDirection = _data['viewDirection'];
    }
  }

  static fromJS(data: any): PlaceVm {
    data = typeof data === 'object' ? data : {};
    let result = new PlaceVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['selected'] = this.selected;
    data['viewDirection'] = this.viewDirection;
    return data;
  }
}

export interface IPlaceVm {
  id?: number;
  name?: string | undefined;
  selected?: boolean;
  viewDirection?: ViewDirection;
}

export class CertificationDataVm implements ICertificationDataVm {
  id?: number;
  type?: CertificationType;
  price?: number;
  oldPrice?: number;
  isAvailable?: boolean;
  selected?: boolean;

  constructor(data?: ICertificationDataVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.type = _data['type'];
      this.price = _data['price'];
      this.oldPrice = _data['oldPrice'];
      this.isAvailable = _data['isAvailable'];
      this.selected = _data['selected'];
    }
  }

  static fromJS(data: any): CertificationDataVm {
    data = typeof data === 'object' ? data : {};
    let result = new CertificationDataVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['type'] = this.type;
    data['price'] = this.price;
    data['oldPrice'] = this.oldPrice;
    data['isAvailable'] = this.isAvailable;
    data['selected'] = this.selected;
    return data;
  }
}

export interface ICertificationDataVm {
  id?: number;
  type?: CertificationType;
  price?: number;
  oldPrice?: number;
  isAvailable?: boolean;
  selected?: boolean;
}

export class PostResult implements IPostResult {
  postId?: string | undefined;
  permaKey?: string | undefined;
  paymentKey?: string | undefined;

  constructor(data?: IPostResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.postId = _data['postId'];
      this.permaKey = _data['permaKey'];
      this.paymentKey = _data['paymentKey'];
    }
  }

  static fromJS(data: any): PostResult {
    data = typeof data === 'object' ? data : {};
    let result = new PostResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['postId'] = this.postId;
    data['permaKey'] = this.permaKey;
    data['paymentKey'] = this.paymentKey;
    return data;
  }
}

export interface IPostResult {
  postId?: string | undefined;
  permaKey?: string | undefined;
  paymentKey?: string | undefined;
}

export class PostsPutStatusCommand implements IPostsPutStatusCommand {
  postId!: string;
  status?: PostStatus;

  constructor(data?: IPostsPutStatusCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.postId = _data['postId'];
      this.status = _data['status'];
    }
  }

  static fromJS(data: any): PostsPutStatusCommand {
    data = typeof data === 'object' ? data : {};
    let result = new PostsPutStatusCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['postId'] = this.postId;
    data['status'] = this.status;
    return data;
  }
}

export interface IPostsPutStatusCommand {
  postId: string;
  status?: PostStatus;
}

export class PostsCloseCommand implements IPostsCloseCommand {
  postId!: string;
  closeReasonId?: number;
  closeReason?: LocalizedStringDto | undefined;

  constructor(data?: IPostsCloseCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.postId = _data['postId'];
      this.closeReasonId = _data['closeReasonId'];
      this.closeReason = _data['closeReason']
        ? LocalizedStringDto.fromJS(_data['closeReason'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): PostsCloseCommand {
    data = typeof data === 'object' ? data : {};
    let result = new PostsCloseCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['postId'] = this.postId;
    data['closeReasonId'] = this.closeReasonId;
    data['closeReason'] = this.closeReason ? this.closeReason.toJSON() : <any>undefined;
    return data;
  }
}

export interface IPostsCloseCommand {
  postId: string;
  closeReasonId?: number;
  closeReason?: LocalizedStringDto | undefined;
}

export class PrivacyPolicyVm implements IPrivacyPolicyVm {
  content?: string | undefined;

  constructor(data?: IPrivacyPolicyVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.content = _data['content'];
    }
  }

  static fromJS(data: any): PrivacyPolicyVm {
    data = typeof data === 'object' ? data : {};
    let result = new PrivacyPolicyVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['content'] = this.content;
    return data;
  }
}

export interface IPrivacyPolicyVm {
  content?: string | undefined;
}

export class PrivacyPolicyDto implements IPrivacyPolicyDto {
  content?: string | undefined;

  constructor(data?: IPrivacyPolicyDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.content = _data['content'];
    }
  }

  static fromJS(data: any): PrivacyPolicyDto {
    data = typeof data === 'object' ? data : {};
    let result = new PrivacyPolicyDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['content'] = this.content;
    return data;
  }
}

export interface IPrivacyPolicyDto {
  content?: string | undefined;
}

/** 0 = En 1 = Ar */
export enum Language {
  En = 0,
  Ar = 1,
}

export class PrivacyPoliciesPutCommand implements IPrivacyPoliciesPutCommand {
  content!: string;
  lang?: Language;

  constructor(data?: IPrivacyPoliciesPutCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.content = _data['content'];
      this.lang = _data['lang'];
    }
  }

  static fromJS(data: any): PrivacyPoliciesPutCommand {
    data = typeof data === 'object' ? data : {};
    let result = new PrivacyPoliciesPutCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['content'] = this.content;
    data['lang'] = this.lang;
    return data;
  }
}

export interface IPrivacyPoliciesPutCommand {
  content: string;
  lang?: Language;
}

export class RegionDashboardVm implements IRegionDashboardVm {
  id?: number;
  name?: string | undefined;
  subRegions?: SubRegionDashboardVm[] | undefined;

  constructor(data?: IRegionDashboardVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      if (Array.isArray(_data['subRegions'])) {
        this.subRegions = [] as any;
        for (let item of _data['subRegions'])
          this.subRegions!.push(SubRegionDashboardVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): RegionDashboardVm {
    data = typeof data === 'object' ? data : {};
    let result = new RegionDashboardVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    if (Array.isArray(this.subRegions)) {
      data['subRegions'] = [];
      for (let item of this.subRegions) data['subRegions'].push(item.toJSON());
    }
    return data;
  }
}

export interface IRegionDashboardVm {
  id?: number;
  name?: string | undefined;
  subRegions?: SubRegionDashboardVm[] | undefined;
}

export class SubRegionDashboardVm implements ISubRegionDashboardVm {
  id?: number;
  name?: string | undefined;

  constructor(data?: ISubRegionDashboardVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
    }
  }

  static fromJS(data: any): SubRegionDashboardVm {
    data = typeof data === 'object' ? data : {};
    let result = new SubRegionDashboardVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    return data;
  }
}

export interface ISubRegionDashboardVm {
  id?: number;
  name?: string | undefined;
}

export class PaginatedListOfRegionDto implements IPaginatedListOfRegionDto {
  pageInfo?: PageInfo | undefined;
  items?: RegionDto[] | undefined;

  constructor(data?: IPaginatedListOfRegionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(RegionDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfRegionDto {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfRegionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfRegionDto {
  pageInfo?: PageInfo | undefined;
  items?: RegionDto[] | undefined;
}

export class RegionDto implements IRegionDto {
  id?: number;
  name?: LocalizedStringDto | undefined;
  videoUrl?: string | undefined;
  isSupported?: boolean;
  cityId?: number;

  constructor(data?: IRegionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.videoUrl = _data['videoUrl'];
      this.isSupported = _data['isSupported'];
      this.cityId = _data['cityId'];
    }
  }

  static fromJS(data: any): RegionDto {
    data = typeof data === 'object' ? data : {};
    let result = new RegionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['videoUrl'] = this.videoUrl;
    data['isSupported'] = this.isSupported;
    data['cityId'] = this.cityId;
    return data;
  }
}

export interface IRegionDto {
  id?: number;
  name?: LocalizedStringDto | undefined;
  videoUrl?: string | undefined;
  isSupported?: boolean;
  cityId?: number;
}

export class ServiceVm implements IServiceVm {
  id?: number;
  percentage?: number;
  type?: ServiceTypeVm | undefined;

  constructor(data?: IServiceVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.percentage = _data['percentage'];
      this.type = _data['type'] ? ServiceTypeVm.fromJS(_data['type']) : <any>undefined;
    }
  }

  static fromJS(data: any): ServiceVm {
    data = typeof data === 'object' ? data : {};
    let result = new ServiceVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['percentage'] = this.percentage;
    data['type'] = this.type ? this.type.toJSON() : <any>undefined;
    return data;
  }
}

export interface IServiceVm {
  id?: number;
  percentage?: number;
  type?: ServiceTypeVm | undefined;
}

export class ServiceTypeVm implements IServiceTypeVm {
  id?: number;
  name?: string | undefined;
  order?: number;

  constructor(data?: IServiceTypeVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.order = _data['order'];
    }
  }

  static fromJS(data: any): ServiceTypeVm {
    data = typeof data === 'object' ? data : {};
    let result = new ServiceTypeVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['order'] = this.order;
    return data;
  }
}

export interface IServiceTypeVm {
  id?: number;
  name?: string | undefined;
  order?: number;
}

export class PaginatedListOfServiceDto implements IPaginatedListOfServiceDto {
  pageInfo?: PageInfo | undefined;
  items?: ServiceDto[] | undefined;

  constructor(data?: IPaginatedListOfServiceDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(ServiceDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfServiceDto {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfServiceDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfServiceDto {
  pageInfo?: PageInfo | undefined;
  items?: ServiceDto[] | undefined;
}

export class ServiceDto implements IServiceDto {
  id?: number;
  percentage?: number;
  typeId?: number;
  regionId?: number;
  subRegionId?: number | undefined;
  region?: RegionDashboardVm | undefined;
  type?: ServiceTypeVm | undefined;

  constructor(data?: IServiceDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.percentage = _data['percentage'];
      this.typeId = _data['typeId'];
      this.regionId = _data['regionId'];
      this.subRegionId = _data['subRegionId'];
      this.region = _data['region']
        ? RegionDashboardVm.fromJS(_data['region'])
        : <any>undefined;
      this.type = _data['type'] ? ServiceTypeVm.fromJS(_data['type']) : <any>undefined;
    }
  }

  static fromJS(data: any): ServiceDto {
    data = typeof data === 'object' ? data : {};
    let result = new ServiceDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['percentage'] = this.percentage;
    data['typeId'] = this.typeId;
    data['regionId'] = this.regionId;
    data['subRegionId'] = this.subRegionId;
    data['region'] = this.region ? this.region.toJSON() : <any>undefined;
    data['type'] = this.type ? this.type.toJSON() : <any>undefined;
    return data;
  }
}

export interface IServiceDto {
  id?: number;
  percentage?: number;
  typeId?: number;
  regionId?: number;
  subRegionId?: number | undefined;
  region?: RegionDashboardVm | undefined;
  type?: ServiceTypeVm | undefined;
}

export class ServicesPostPutCommand implements IServicesPostPutCommand {
  percentage?: number;
  typeId?: number;
  regionId?: number;
  subRegionId?: number | undefined;

  constructor(data?: IServicesPostPutCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.percentage = _data['percentage'];
      this.typeId = _data['typeId'];
      this.regionId = _data['regionId'];
      this.subRegionId = _data['subRegionId'];
    }
  }

  static fromJS(data: any): ServicesPostPutCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ServicesPostPutCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['percentage'] = this.percentage;
    data['typeId'] = this.typeId;
    data['regionId'] = this.regionId;
    data['subRegionId'] = this.subRegionId;
    return data;
  }
}

export interface IServicesPostPutCommand {
  percentage?: number;
  typeId?: number;
  regionId?: number;
  subRegionId?: number | undefined;
}

export class ServicesPostCommand
  extends ServicesPostPutCommand
  implements IServicesPostCommand {
  constructor(data?: IServicesPostCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
  }

  static fromJS(data: any): ServicesPostCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ServicesPostCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface IServicesPostCommand extends IServicesPostPutCommand {}

export class ServicesPutCommand
  extends ServicesPostPutCommand
  implements IServicesPutCommand {
  id?: number;

  constructor(data?: IServicesPutCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): ServicesPutCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ServicesPutCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    super.toJSON(data);
    return data;
  }
}

export interface IServicesPutCommand extends IServicesPostPutCommand {
  id?: number;
}

export class ServiceTypeDto implements IServiceTypeDto {
  id?: number;
  name?: LocalizedStringDto | undefined;
  order?: number;

  constructor(data?: IServiceTypeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.order = _data['order'];
    }
  }

  static fromJS(data: any): ServiceTypeDto {
    data = typeof data === 'object' ? data : {};
    let result = new ServiceTypeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['order'] = this.order;
    return data;
  }
}

export interface IServiceTypeDto {
  id?: number;
  name?: LocalizedStringDto | undefined;
  order?: number;
}

export class ServiceTypesPostPutCommon implements IServiceTypesPostPutCommon {
  name?: LocalizedStringDto | undefined;

  constructor(data?: IServiceTypesPostPutCommon) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): ServiceTypesPostPutCommon {
    data = typeof data === 'object' ? data : {};
    let result = new ServiceTypesPostPutCommon();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    return data;
  }
}

export interface IServiceTypesPostPutCommon {
  name?: LocalizedStringDto | undefined;
}

export class ServiceTypesPostCommand
  extends ServiceTypesPostPutCommon
  implements IServiceTypesPostCommand {
  constructor(data?: IServiceTypesPostCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
  }

  static fromJS(data: any): ServiceTypesPostCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ServiceTypesPostCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface IServiceTypesPostCommand extends IServiceTypesPostPutCommon {}

export class ServiceTypesPutCommand
  extends ServiceTypesPostPutCommon
  implements IServiceTypesPutCommand {
  id?: number;

  constructor(data?: IServiceTypesPutCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): ServiceTypesPutCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ServiceTypesPutCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    super.toJSON(data);
    return data;
  }
}

export interface IServiceTypesPutCommand extends IServiceTypesPostPutCommon {
  id?: number;
}

export class ServiceTypesPutOrderCommand implements IServiceTypesPutOrderCommand {
  id?: number;
  order?: number;

  constructor(data?: IServiceTypesPutOrderCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.order = _data['order'];
    }
  }

  static fromJS(data: any): ServiceTypesPutOrderCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ServiceTypesPutOrderCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['order'] = this.order;
    return data;
  }
}

export interface IServiceTypesPutOrderCommand {
  id?: number;
  order?: number;
}

export class PaginatedListOfSubRegionDto implements IPaginatedListOfSubRegionDto {
  pageInfo?: PageInfo | undefined;
  items?: SubRegionDto[] | undefined;

  constructor(data?: IPaginatedListOfSubRegionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(SubRegionDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfSubRegionDto {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfSubRegionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfSubRegionDto {
  pageInfo?: PageInfo | undefined;
  items?: SubRegionDto[] | undefined;
}

export class SubRegionDto implements ISubRegionDto {
  id?: number;
  name?: LocalizedStringDto | undefined;
  isSupported?: boolean;
  regionId?: number;
  parentId?: number | undefined;

  constructor(data?: ISubRegionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.isSupported = _data['isSupported'];
      this.regionId = _data['regionId'];
      this.parentId = _data['parentId'];
    }
  }

  static fromJS(data: any): SubRegionDto {
    data = typeof data === 'object' ? data : {};
    let result = new SubRegionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['isSupported'] = this.isSupported;
    data['regionId'] = this.regionId;
    data['parentId'] = this.parentId;
    return data;
  }
}

export interface ISubRegionDto {
  id?: number;
  name?: LocalizedStringDto | undefined;
  isSupported?: boolean;
  regionId?: number;
  parentId?: number | undefined;
}

export class SubRegionsPostPutCommon implements ISubRegionsPostPutCommon {
  name?: LocalizedStringDto | undefined;
  isSupported?: boolean;
  regionId?: number;
  parentId?: number | undefined;

  constructor(data?: ISubRegionsPostPutCommon) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.isSupported = _data['isSupported'];
      this.regionId = _data['regionId'];
      this.parentId = _data['parentId'];
    }
  }

  static fromJS(data: any): SubRegionsPostPutCommon {
    data = typeof data === 'object' ? data : {};
    let result = new SubRegionsPostPutCommon();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['isSupported'] = this.isSupported;
    data['regionId'] = this.regionId;
    data['parentId'] = this.parentId;
    return data;
  }
}

export interface ISubRegionsPostPutCommon {
  name?: LocalizedStringDto | undefined;
  isSupported?: boolean;
  regionId?: number;
  parentId?: number | undefined;
}

export class SubRegionsPostCommand
  extends SubRegionsPostPutCommon
  implements ISubRegionsPostCommand {
  constructor(data?: ISubRegionsPostCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
  }

  static fromJS(data: any): SubRegionsPostCommand {
    data = typeof data === 'object' ? data : {};
    let result = new SubRegionsPostCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface ISubRegionsPostCommand extends ISubRegionsPostPutCommon {}

export class SubRegionsPutCommand
  extends SubRegionsPostPutCommon
  implements ISubRegionsPutCommand {
  id?: number;

  constructor(data?: ISubRegionsPutCommand) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): SubRegionsPutCommand {
    data = typeof data === 'object' ? data : {};
    let result = new SubRegionsPutCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    super.toJSON(data);
    return data;
  }
}

export interface ISubRegionsPutCommand extends ISubRegionsPostPutCommon {
  id?: number;
}

export class PaginatedListOfTransactionVm implements IPaginatedListOfTransactionVm {
  pageInfo?: PageInfo | undefined;
  items?: TransactionVm[] | undefined;

  constructor(data?: IPaginatedListOfTransactionVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(TransactionVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfTransactionVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfTransactionVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfTransactionVm {
  pageInfo?: PageInfo | undefined;
  items?: TransactionVm[] | undefined;
}

export class TransactionVm implements ITransactionVm {
  id?: number;
  amount?: number;
  status?: TransactionStatus;
  createdAt?: Date;
  paidAt?: Date | undefined;
  postId?: string | undefined;
  postTitle?: string | undefined;
  accountId?: string | undefined;
  accountName?: string | undefined;

  constructor(data?: ITransactionVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.amount = _data['amount'];
      this.status = _data['status'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : <any>undefined;
      this.paidAt = _data['paidAt']
        ? new Date(_data['paidAt'].toString())
        : <any>undefined;
      this.postId = _data['postId'];
      this.postTitle = _data['postTitle'];
      this.accountId = _data['accountId'];
      this.accountName = _data['accountName'];
    }
  }

  static fromJS(data: any): TransactionVm {
    data = typeof data === 'object' ? data : {};
    let result = new TransactionVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['amount'] = this.amount;
    data['status'] = this.status;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
    data['paidAt'] = this.paidAt ? this.paidAt.toISOString() : <any>undefined;
    data['postId'] = this.postId;
    data['postTitle'] = this.postTitle;
    data['accountId'] = this.accountId;
    data['accountName'] = this.accountName;
    return data;
  }
}

export interface ITransactionVm {
  id?: number;
  amount?: number;
  status?: TransactionStatus;
  createdAt?: Date;
  paidAt?: Date | undefined;
  postId?: string | undefined;
  postTitle?: string | undefined;
  accountId?: string | undefined;
  accountName?: string | undefined;
}

/** 0 = Pending 1 = Paid 2 = InProgress 3 = Rejected 4 = Refunding 5 = Refunded */
export enum TransactionStatus {
  Pending = 0,
  Paid = 1,
  InProgress = 2,
  Rejected = 3,
  Refunding = 4,
  Refunded = 5,
}

export interface FileParameter {
  data: any;
  fileName: string;
}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): Observable<any> {
  if (result !== null && result !== undefined) return _observableThrow(result);
  else
    return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next('');
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = (event) => {
        observer.next((<any>event.target).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
